<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
    
      
    
    
      
    
  <script async src="//cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  <link href="//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />


<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">




  

<link href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo个人博客,NexT美化优化,哈林摇,Mac Panel特效,Leaf,科科,Java程序员,广州,旅行,摄像,Github Pages,搭建教程,demo,博客相册,文章排行榜,网站SEO" />










<meta name="description" content="Welcome to KLN，here are base kownledge of Kotlin.Kotlin language is the first android developer language after Google declared years ago. 写在前言1. kotlin 概述1.1. 程序结构如果 Kotlin 文件包含单个类（其他的顶层声明不影响），那么文件名应该">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin Learn Note">
<meta property="og:url" content="http://yoursite.com/2021/03/22/kotlinStudy/index.html">
<meta property="og:site_name" content="Keke">
<meta property="og:description" content="Welcome to KLN，here are base kownledge of Kotlin.Kotlin language is the first android developer language after Google declared years ago. 写在前言1. kotlin 概述1.1. 程序结构如果 Kotlin 文件包含单个类（其他的顶层声明不影响），那么文件名应该">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-22T12:38:00.000Z">
<meta property="article:modified_time" content="2021-04-20T12:51:32.135Z">
<meta property="article:author" content="YkekeY">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"flipYIn","post_header":"perspectiveRightIn","post_body":"perspectiveLeftIn","coll_header":"swoopIn","sidebar":"shrinkIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/22/kotlinStudy/"/>





<!-- 设置文章需要密码访问 -->
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>Kotlin Learn Note | Keke</title>
  









  
      <!-- 球型气泡标签云 -->
      <script type="text/javascript" src="/js/src/bubble.js"></script>
  

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <!--fork me from github-->
    <a href="https://github.com/leafjame/hexo-theme-next5-leaf" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Keke</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home/主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            home/主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives/文章">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            archives/文章
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/technology/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/life/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-links">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br />
            
            友链
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/22/kotlinStudy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YkekeY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/keke.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keke">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Kotlin Learn Note</h2>
        

        <div class="post-meta">
          <span class="post-time">

             
                 <i class="fa fa-thumb-tack"></i>
                 <font color=7D26CD>置顶</font>
                 <span class="post-meta-divider">|</span>
             

             

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-22T20:38:00+08:00">
                2021-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/22/kotlinStudy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/03/22/kotlinStudy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          <!--
          
          -->

          
            <span class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                <span title="Words count in article">
                  
                </span>
              

              

              
            </span>
          

          <!-- 隐藏文章内标题下，内容描述
          
          -->

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Welcome to KLN，here are base kownledge of Kotlin.Kotlin language is the first android developer language after Google declared years ago.</p>
<h1 id="写在前言"><a href="#写在前言" class="headerlink" title="写在前言"></a>写在前言</h1><h1 id="1-kotlin-概述"><a href="#1-kotlin-概述" class="headerlink" title="1. kotlin 概述"></a>1. kotlin 概述</h1><dl><dt>1.1. 程序结构<br>如果 Kotlin 文件包含单个类（其他的顶层声明不影响），那么文件名应该与该类的名称相同，<br>并用.kt 扩展名。如果文件包含多个类或只包含顶层声明，那不要求与类相同。<br>建议多个相关的类、顶级函数或者属性等内容放在同一个文件中。特别是为类定义与类相关<br>的扩展函数时，将它们放在与类自身定义相同的地方。<br>1.2. 程序入口点<br>Kotlin 应用程序的入口点是 main 函数，例如：<br>fun main(){<br>println(“Hello world!”)<br>}<br>1.3. 标签<br>kotlin 中任何表达式都可以用标签（label）来标记，格式：<br>labelname@<br>应用：<br>loop@ for( … ){}<br>在程序中，跳转指令就可以跳转到标签所在位置，例如：break@loop。<br>1.4. 编码规则<br> 区分大小写<br> 单行语句不需要分号结束，若一行有多个语句，需要用分号隔开<br> 字符串不能分开在两行中书写，若要分开，可以将之拆分成两个字符，用加号（+）连接<br> 注释：单行：// ，多行： /* <em>/ ，文档注释：/*</em> */，且注释可以嵌套<br>1.5. 常用符号<br>? 空值处理之可空类型变量<br>?. 空值处理之安全调用符<br>?: 空值处理之 Elvis 操作符<br>!!. 空值处理之非空断言<br>! 空值处理之平台类型标记</dt><dd>类型声明，继承、接口<br>:: 函数类型之函数参数、反射<br>== 比较两个值大小，即 java 中的 equals 方法<br>=== 比较对象地址，即比较两个对象是否相同””” “”” 字符串之原生符号<br>$ 字符串之模板表达式</dd></dl><h1 id="2-基本语法概述"><a href="#2-基本语法概述" class="headerlink" title="2. 基本语法概述"></a>2. 基本语法概述</h1><p>2.1. 包 Package<br>源文件通常以包声明开都，所以包的声明应处于源文件顶部，源文件的所有内容，都包含在<br>声明的包内。如果没有指明包，该文件的内容属于无名字的默认包。格式为：<br>package com.xx<br>有多个包会默认导入到每个 kotlin 文件中，例如：<br>kotlin.*<br>kotlin.annotation.*<br>kotlin.collections.*<br>kotlin.comparisons.*<br>kotlin.io.*<br>kotlin.ranges.*<br>kotlin.sequences.*<br>kotlin.text.*<br>2.2. 导入 import<br>除了默认导入之外，每个文件可以包含它自己的导入指令。<br>可以导入一个单独的名字，如：<br>import org.example.Message // 现在 Message 可以不用限定符访问<br>也可以导入一个作用域下的所有内容（包、类、对象等）:<br>import org.example.* //“org.example”中的一切都可访问<br>如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义：<br>import org.example.Message //Message可访问<br>import org.test.Message as testMessage //testMessage 代表“org.test.Message”<br>import 并不仅限于导入类，也可用它来导入其他声明：<br> 顶层函数及属性；<br> 在对象声明中声明的函数和属性;<br> 枚举常量。<br>2.3. 注解</p>
<p>1) 概述<br>一种描述数据的数据，可以说注解就是源代码的元数据。它作用的对象是代码。它可以给特定的注解代码标注一些额外的信息。例如实现接口中的方法，都会在方法前面加上：@override<br>的注解，这样，此方法的特性就是一个重写的方法，必须满足一定的要求。具体如何处理注解的<br>含义，需要注解处理工具来执行，所以针对一些框架的注解，需要添加注解处理工具插件，例如<br>kotlin 中的 kapt（kotlin Annotation processing tool）。<br>注解以@字符作为名字的前缀，并放在要注解元素的前面。<br>元注解为注解的注解。元注解也是一个标签，但是它是一个特殊的标签，它的作用和目的就<br>是给其他普通的标签进行解释说明的。<br>Kotlin 元注解<br> @Target<br>目标注解，对应的注解类是 kotlin.annotation.Target，功能是指定一个注解的适用目标<br> @Retention<br>保留期注解 ，指定一个新注解的有效范围<br> @Repeatable<br>可重复注解，允许在单个元素上多次使用同一个注解<br> @MustBeDocumented<br>文档注解，该注解可以修饰代码元素（类，接口，函数，属性等）<br>2) 注解的应用<br>//注解声明：和类的声明很类似，只是在 class 前面加上了 annotation 修饰符<br>@Target(AnnotationTarget.FUNCTION)<br>@Retention(value = AnnotationRetention.RUNTIME)<br>annotation class TestAnnotation(val value: Int)<br>class Test {<br>//给 test 函数贴上 TestAnnotation 标签(添加 TestAnnotation 注解)<br>@TestAnnotation(value = 1000)<br>fun test() {<br>…<br>}<br>}<br>3) 在框架中使用注解<br>注解是给机器看的，注释是给程序员看的，这是两者的区别。现在各大框架都在使用注解，<br>程序员需要做的就是知道如何使用注解。<br>注解的使用大体分为三部分: 定义注解、使用注解、解析注解。在框架中定义与解析框架都已<br>经为我们做好了，所以开发的时候定义注解以及解析注解一般不用我们写，只需要学会使用框架<br>提供的注解即可。<br>解析注解需要注解处理工具处理，例如 Room 中自动生成代码等。此时需要添加注解处理工<br>具插件和添加依赖。2.4. 常量<br>声明常量的关键字：const<br>声明常量的方式：<br>const val 常量名 = 值<br>const 只能修饰 val，不能修饰 var<br>声明常量的三种正确方式<br> 在顶层声明<br> 在 object 修饰的类中声明，在 kotlin 中称为对象声明，它相当于 Java 中一种形式的单<br>例类<br> 在伴生对象中声明<br>例如：<br>// 1. 顶层声明<br>const val NUM_A : String = “顶层声明”<br>// 2. 在 object 修饰的类中<br>object TestConst{<br> const val NUM_B = “object 修饰的类中”<br>}<br>// 3. 伴生对象中<br>class TestClass{<br> companion object {<br> const val NUM_C = “伴生对象中声明”<br> }<br>}<br>fun main(args: Array<String>) {<br> println(“NUM_A： $NUM_A”)<br> println(“NUM_B： ${TestConst.NUM_B}”)<br> println(“NUM_C： ${TestClass.NUM_C}”)<br>}<br>2.5. 变量<br>kotlin 中，变量的声明必须使用 var 或 val 关键字。定义格式：<br>val/var 变量名:数据类型 = xxx<br>在定义时直接赋值，编译器可以推导其类型，所以可以省略类型，格式简化为：<br>val/var 变量名= xxx<br> val（value）用此关键字声明的变量表示不可变变量，即只读变量。相当于 Java 中的 final 变量。<br>注意：若 val 修饰的是一个对象，例如：val myUser = User()，那表示定义了一个 myUser<br>的引用，指向了一个 User 对象，且一旦定义后，此引用不能再指向别的对象。但是，User 对象<br>本身的值是可以改变的。<br> var（variable）<br>用此关键字声明的变量表示可变变量，即可读且可写。相当于 Java 中普通变量。<br>注意：kotlin 中不可以一次定义多个变量，例如：var a,b,c 这是错误的<br>例如：<br>//完整的定义格式<br>val a:Int=8<br>var var_a: Int = 10<br>//自动推断出 Int 类型<br>val b=2<br>var var_b = 5<br>//如果没有初始值，类型不能省略<br>val c:Int<br>c=3 //明确赋值，后面不能再次修改，例如： c += 1，这是错误的<br>var var_c: Float<br>var_c = 12.3f<br>var_c += 1 //可变变量，正确<br>注意：在不赋值的情况下，只声明变量，没有类型，程序会报错。因为不赋值就无法推导出<br>变量类型，此时就需要显示声明变量类型。例如：<br>var c //错误<br>var c:int //正确<br>val、var 如何选择呢？在程序设计中，优先选择 val，只有当 val 无法满足需求，再使用 var，<br>这样就能保证变量不会被胡乱修改，从而提高了程序的健壮性。</p>
<h1 id="3-空值处理"><a href="#3-空值处理" class="headerlink" title="3. 空值处理"></a>3. 空值处理</h1><p>在程序开发过程中，经常会遇到空指针异常的问题，如果对这个问题处理不当，还可能引起<br>程序的崩溃（crash） ，因此在 Kotlin 中，为了避免出现空指针异常的问题，引入了 Null 机制。<br>3.1. 可空类型变量（？）<br>Kotlin 把变量分成两种类型，一种是可空类型的变量，一种是非空类型的变量。一般情况下，<br>一个变量默认是非空类型。当某个变量的值可以为空时，必须在声明处的数据类型后添加“?”来<br>标识该引用可为空。例如：<br>var name:String //声明非空变量<br>var age:Int? //声明可空变量注意：在使用可空变量时，若不赋初值，则必须要将其赋值为 null，否则会报 “variable ‘xxx’<br>must be initialized”异常。<br>例如：<br>package com.itheima.chapter02.variable<br>fun main(args: Array<String>) {<br>var name: String = “Tom” //非空变量<br>var telephone: String? = null //可空变量<br>if (telephone != null) {<br>print(telephone.length)<br>} else {<br>telephone = “18800008888”<br>print(“telephone =” + telephone)<br>}<br>}<br>上述代码中，在使用可空变量时，必须先对可空变量进行判断，如果 telephone 不为空则输<br>出电话号码的长度，否则赋值为 18800008888 并输出。若不判断，直接输出，会报异常。例如：<br>fun main() {<br> var name:String?=null<br> var result=name.length<br> println(result)<br>}<br>程序会抛出异常，表示只有非空变量或者采用安全调用符才可以调用可空变量。<br>3.2. 安全调用符（?.）<br>上一节中，可空变量在使用时需要通过 if…else 语句进行判断，然后再进行相应的操作。这<br>样的使用方式还是比较复杂，为此 Kotlin 提供了一个安全调用符“?.” ，专门用于调用可空类<br>型变量中的成员方法或属性，其语法格式为“变量?.成员” 。其作用是判断变量是否为 null，如<br>果不为 null 才调用变量的成员方法或者属性。<br>例：<br>fun main(args: Array<String>) {<br>var telephone: String? = null //可空变量<br>var result=telephont?.length //安全调用可空变量<br>println(result)<br>}<br>运行结果为 null，从运行结果可以看到，在使用“?.”调用可空变量的属性时，如果当前变量<br>为空，则程序编译也不会报错，而是返回一个 null 值。所以，非空变量调用是，最简单的方法就是采用安全调用符。<br>3.3. Elvis 操作符（?:）<br>在使用安全调用符调用可空变量中的成员方法或属性时，如果当前变量为空，则会返回一个<br>null 值，但有时即使当前变量为 null，也不想返回一个 null 值，而是指定一个默认值，通过 Elvis<br>操作符（?:）可以指定可空变量为 null 时， 调用该变量中的成员方法或属性的返回值， 其语法<br>格式为 ：<br>表达式?: 表达式<br>如果左侧表达式非空，则返回左侧表达式的值，否则返回右侧表达式的值。当且仅当左侧为<br>空时，才会对右侧表达式求值（短路现象）。<br>例如：<br>fun main(args: Array<String>) {<br>var telephone: String? = null //可空变量<br>var result=telephont?.length?:188000888 //telephone 为空时，使用?:操作符会返<br>回指定的默认值，而非 null。<br>println(result)<br>}<br>运行结果为：188000888<br>3.4. 非空断言（ !!. ）<br>除了通过使用安全调用符（?.）来使用可空类型的变量之外，还可以通过非空断言（!!.）来调<br>用可空类型变量的成员方法或属性。使用非空断言时，语法结构为:<br>变量!!.成员<br>非空断言（!!.）会将任何变量（可空类型变量或者非空类型变量）转换为非空类型的变量，<br>若该变量为空则抛出异常。例如：<br>fun main(args: Array<String>) {<br>var telephone: String? = null //可空变量<br>var result=telephont!!.length //使用非空断言<br>println(result)<br>}<br>运行结果：<br>Exception in thread “main” java.lang.NullPointerException<br>……<br>从运行结果可以看出，程序抛出了空指针异常，如果变量 telephone 赋值不为空，则程序可<br>正常运行。<br>安全调用符与非空断言运算符都可以调用可空变量的方法，但是在使用时有一定的差别，如<br>下表所示。3.5. 平台类型标记<br>Java 中任何引用都可能为 null，而 Kotlin 中只有可空和非空类型，所以 Java 在转换为 Kotlin<br>时，对于部分无法标注的类型，会转换为 Kotlin 中的平台类型。<br>平台类型：其实就是 Kotlin 不知道可空性信息的类型，既可以把它当作可空类型处理，也可<br>以当作非空类型处理，这意味着要像在 java 中对这个数据做 null 判断处理，否则数据为 null 将<br>会抛出空指针异常。<br>平台类型无法在程序中显示标记，所以语言中没有相关的语法。不过，编译器和 IDE 有时需<br>要显示这些类型（错误信息，参数信息等等），所以 Kotlin 提供了“!”助记符，例如：<br> T!表示 T 或 T?<br> Array&lt;(out) T&gt;!表示类型为 T 或 T 的子类的 Java 集合，可以为空或不为空</p>
<h1 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4. 基本类型"></a>4. 基本类型</h1><p>在 kotlin 中，所有的东西都是对象，在这个意义上，可以在任何变量上调用成员函数与属性。<br>一些类型可以有特殊的内部表示，例如：数字，字符以及布尔值可以在运行时表示为原生类<br>型值。4.1. 类型推断<br>类型推断：编译器可以从上下文推断类型（赋予某个变量的表达式值）。<br>当变量声明和初始化工作一起执行时，即可省略类型声明。<br>4.2. 数字<br>Kotlin 中的数字的内置类型，其关键字为：<br>Byte：字节，8 位<br>Short：短整型，16 位<br>Int：整型，32 位<br>Long：长整型，64 位<br>Float：浮点型，32 位<br>Double：双精度浮点型，64 位</p>
<p>1) 字面常量<br>数值常量字面值有以下几种:<br> 十进制：123<br>Long 类型用大写 L标记: 123L<br> 十六进制: 0x0F<br> 二进制:0b00001011<br>注意: 不支持八进制<br>Kotlin 同样支持浮点数的常规表示方法:<br> 默认 double：123.5、123.5e10<br> Float：用 f或者 F 标记：123.5f<br>另外，在表示数值是，可以使用下划线来让数字更加易读，例：val om=1_000_000<br>2) 整数：<br>定义常量时，所有未超出 Int 最大值的整型值都会推断为 Int 类型。如果初始值超过了其最大<br>值，那么推断为 Long 类型。如需显式指定 Long 类型值，需在该值后面加上 L 后缀。例如：<br>val one=1 //Int<br>val threeBillion 300000000 //Long<br>val oneLong=1L //Long<br>val oneByte:Byte=1 //Byte<br>3) 浮点数：<br>对于以小数初始化的变量，编译器会推断为 Double 类型。如 需 将 一 个 值 显 式 指 定 为<br>Float 类型，添加 f 或 F 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入。<br>val pi = 3.14 //Double<br>val e = 2.7182818284 //Double<br>val eFloat= 2.7182818284f //Float，实际值为 2.7182817注意，由于不同的表示方式，较小类型并不是较大类型的子类型，所以 Kotlin 不支持取值范<br>围小的数据类型隐式转换为取值范围大的类型。在赋值时，要求不同数值类型的变量或值之间必<br>须进行显式转换。例如：<br>//隐式转换，编译器会报错<br>val aInt: Int = 5<br>val cLong: Long = aInt<br>//需要去显式的转换,下面这个才是正确的<br>val dLong: Long = aInt.toLong()<br>显示转换是通过 toXxx()方法将变量或值转换为另外的类型（注意，函数转换的是变量的值拷<br>贝，转换后是一个新值，与原变量无关，原变量的类型是不会变的，与 C 语言是一样的概念）：<br>toByte() ：转换为 Byte<br>toShort()：转换为 Short<br>toInt()：转换为 Int<br>toLong()：转换为 Long<br>toFloat()：转换为 Float<br>toDouble()：转换为 Double<br>toChar()：转换为 Char<br>4) 表达式类型自动提升：<br>当一个算术表达式中包含多个数值型的值时，整个算术表达式的数据类型将发生自动提升。<br>（与 Java 基本相似的自动提升规则）。<br>所有的 Byte、Short 类型将被提升到 Int 类型，整个算术表达式的数据类型自动提升到与表<br>达式中最高等级操作数同样的类型。<br>例如：<br> var b: Byte = 40<br> var c: Short = 97<br> var i: Int = 23<br> var d: Double = .314<br> val result = b + c + i * d //变量的值发生类型提升，变量本身类型不变<br> println(result) //144.22，类型为 Double<br>4.3. boolean 型<br>用“Boolean”表示，只有两个值，分别是 true 和 false。例如：<br>var a:Boolean=true<br>var b=true4.4. 逻辑运算符：&amp;&amp; , || , ! （与 java 相同，略）<br>4.5. 字符型<br>用“Char”表示。每个字符类型的变量占用 2 个直接。在使用字符常量时，需要用单引号将<br>字符括起来，例如：<br>var a:Char =’A’<br>var b=’B’<br>注意，kotlin 中，Char 类型的变量不能直接赋值为数字，必须使用单引号把数字括起来才能<br>使用。<br>4.6. 字符串</p>
<p>1) 表示格式<br>用“String”表示。在使用字符串常量时，需要用双引号将字符括起来，例如：<br>var a: String = “Hello World!”<br>var a = “Hello World!”<br>字符串中的元素可以通过索引的形式访问，例如：a[i]。<br>字符串的长度可以通过属性 length 获取，例如：”abc”.length，值为 3。<br>2) toString()函数<br>kotlin 中，所有对象的基类是 Any 类，Any 类中的 toString()方法可以将其他类型的数值转<br>换为 String 类型。<br>3) 字符串常用处理函数<br>函数 功能描述<br>first()/last()/get(index) 查找字符串的第 1 个/最后一个/第 index 个元素<br>subString(startindex:Int) 从下标为 startindex 开始截取，直至末尾，返回截取的字符串<br>subString(startindex:Int,<br>endindex:Int)<br>从 startindex~ endindex-1,截取字符串<br>subString(range:IntRange) IntRange 表示截取范围。<br>subSequence(…) 与上面的 substring 一致。<br>replace(oldChar,newChar) oldChar 为要被替换的字符串,newChar 为新字符串<br>split(separator:String) 分隔字符串，例如：str.split(“.”)，根据点号拆分<br>trim()/trimEnd()/… 删除字符串前面的空格，字符后面的空格<br>4) 转义字符<br>与 java 中一致，略。<br>5) 原生字符串<br>使用 3 对引号（””” …”””），包左右的字符括起来。原生字符可以保证字符串中原有内容<br>的输出，即使包含转义字符也不会被转义。6) 模板表达式$<br>模板表达式：在字符串中添加占位符。由：${变量名/函数/表达式} 组成，后面是变量名时，<br>可以省略{}(函数和表达式不行)，例如：$变量名。<br>注意，原生字符串中，使用模板表达式输出“$”需要使用：${$}<br>例 1：使用模板表达式存储字符串的值<br>var a=1<br>var s1=”a is ${a}” // a is 1<br>var s2=”a is $a” // a is 1<br>例 2：使用模板表达式调用其他方法<br>fun helloWorld():String{<br>return “Hello World”<br>}<br>fun main(args:Array<String>){<br>//语法格式：${方法()}<br>println( “${helloWorld()}” ) //{}不能少<br>}<br>例 3：使用模板表达式执行替换操作<br>var s2=”a is 1”<br>//语法格式：${表达式} ，执行表达式<br>var s3=”${s2.replace(“is”,”wa”)}” //s3 为：a was 1<br>4.7. 数组</p>
<p>1) 数组型<br>数组类型用 Array 表示，加上泛型后，表示方式为 Array<T>。<br>创建数组的方式：<br> arrayOf()：创建一个数组，参数是一个可变参数的泛型对象，此方法最常用<br>例如：<br>var int_ary: Array<Int> = arrayOf(1, 2, 3)<br>var str_ary:Array<String> = arrayOf(“happy”,”new”,”year”)<br>注意：<String> =之间要有空格，不然会被解释为 &gt;=，比较运算了。<br> arrayOfNulls()：用于创建一个指定数据类型且可以为空元素的数组<br>例如：<br>var arr= arrayOfNulls<Int>(3) //注意，类型，数量<br> Array()：工厂函数<br>此函数有两个参数，第一个为数组元素个数，第二个为使用其元素下标（特殊变量 index）<br>组成的表达式，例如：var arr = Array(5,{index -&gt; (index * 2).toString() }) //5 为元素个数，index 为下标<br>2) 原生类型数组<br>kotlin 中有专门的类来表示原生类型的数组，分别是：<br> ByteArray：字节型数组<br> ShortArray：短整型数组<br> IntArray：整型数组<br> LongArray：长整型数组<br> BooleanArray：布尔型数组<br> CharArray：字符型数组<br> FloatArray：浮点型数组<br> DoubleArray：双精度浮点型数组<br>对 应 这 些 原 始 类 型 ， 初 始 化 数 组 时 ， 它 们 也 有 相 应 的 方 法 ： typeArrayOf(xxx)<br>（ByteArrayOf(xxx)、IntArrayOf(xxx)、……）。例如：<br>val arr:IntArray = intArrayOf(1,2,3)<br>或者采用构造函数、工厂方法，例如：<br>var arr=IntArray(5) //构造函数创建对象，默认初始值为 0<br>var arr=IntArray(5,{it *1} ) //使用 lambda 表达式初始化数组中的值<br>从上面的类型可以看到，原生类型只能是基础类型的数组，注意，不支持字符串等复合类型<br>为原始类型，即 stringArray 是错误的，必须使用 Array<String>这样的格式。<br>另外，由于智能推断，在初始化数组变量时，变量的数据类型同样可以省略，例如：<br>var string_array = arrayOf(“Hello”, “World”, “!”)”<br>数组常用属性：<br>Array.size：获取数组长度<br>注意：数组中的索引不能超出索引的范围，不然程序会报错。<br>4.8. 区间</p>
<p>1) 正向区间（从小到大）<br>区间是数值序列的一种定义方式，并通过序列中的首、尾值表示。范围可利用两个“.”表示，<br>也可以通过 rangeTo(other:Int)函数，如下所示：<br>val intRange=1..4 //表示 1,2,3,4 这 4 个值的区间<br>val charRange=’b’.. ‘g’ //表示从字母 b~g 区间<br>i in 1.rangeTo(4) //判断 i 是否在[1,4]的范围内<br>kotlin 中，还有一个函数 until(to:Int)，该函数输出的区间不包含结尾元素，且使用时可以省<br>略()，并和前面的对象之间不需要点号，在 until 后面加上空格，再后面加上范围，例如：<br>i =1.until( 4 ) //i 的范围是：[ 1 , 4 ）<br>i =1 until 4注意，区间不是一个具体的值，不能将它赋值给一个 int 变量，例如语句：<br>var a=1.rangeTo(4)<br>print(a) //输出的结果是：1..4，表示是一个区间，而不是一个具体的值<br>in 运算符的使用：<br>in 和区间一起使用，表示在…区间。!in 也是运算符，正好和 in 相反，表示不在…区间。运<br>算的结果是一个 boolean。<br>另外，in 用在 for 循环中，for( 循环变量 in 循环条件 )，表示迭代循环条件中的值。<br>2) 逆向区间（从大到小）<br>函数：downTo(to:Int)，该函数可以省略()，省略时，在 downTo 后面加上空格，然后加上<br>范围值即可。例如：<br>5.downTo(1) / 5 downTo 1 //i 的范围是：[5,1]<br>3) 步长<br>前面的步长默认为 1，可以使用 step(step:Int)函数来指定，step 中的()也可以省略，书写时<br>在 step 后面加上空格，空格后面加上步长即可。例如：<br>1..4 step 2 //取值为 1,3<br>4.9. 类型转换<br>类型转换是指将某一特定类型的对象转换为另一种类型。在 kotlin 中，根据转换方式的不同，<br>数据类型转换分为两种：智能类型转换和强制类型转换。<br>与“数字”章节中的强制类型转换不同，这里的转换是变量类型的转换，而不是值拷贝的转<br>换，注意，类型必须是能够转换的，例如子类转换为父类，或者类型推断后为同一个类型。</p>
<p>1) 智能类型转换<br>is 和 !is 操作符，通过这两个操作符，能判断出当前对象是否属于 is 或者 !is 后面的数据类<br>型（返回 boolean）。如果当前对象属于 is 后面的数据类型，则在使用该对象时可以自动进行智<br>能类型转换。<br>例如：<br>var a:Any=”hello”<br>if( a is String ){ //a 自动转换为 String 类型，且返回 true<br>println( “字符串长度”+a.length )<br>} else{<br>println(“I don’t konw”)<br>}<br>上述代码中，定义了一个 Any 类型变量 a，当通过“is”操作符进行判断时，编辑器可以判<br>断变量 a 中实际上存储的是一个 String 类型的数据，会自动将 a 转换为 String 类型。<br>2) 强制类型转换<br> 将对象转换为不同类型；或者将可空类型隐式的转换为非空类型（智能转换机制）as 非安全型转换，转换无法实现时，抛出 ClassCastException 异常，例如：<br>var a=”1” //定义变量 a，没有指定具体类型，但可以智能推导出 String 类型<br>var b:String = a as String //将变量 a 强制转换为 String 类型<br>而如果 a 定义为其他类型，程序将会抛出异常，例如：<br>var a=1 //定义变量 a，智能推导出 Int 类型<br>var b:String = a as String //将 int 变量 a 强制转换为 String 类型，抛出异常，指出这个<br>类型转换不会成功<br>as? 安全型转换，该操作符表示转换无法实现时，返回 null，不会抛出异常。例如：<br>var a=1 //定义变量 a，智能推导出 Int 类型<br>var b:String？ = a as？ String //b 的值为 null，转换无法实现<br>var c: Float? = a as? Float //c 的值为 null，Int 无法转换为 Float</p>
<h1 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h1><p>与 Java 中一致，略</p>
<h1 id="6-控制流"><a href="#6-控制流" class="headerlink" title="6. 控制流"></a>6. 控制流</h1><p>6.1. if 语句<br>格式：<br> if(条件) 语句/{语句块}<br> if(条件)-else<br>另外还有:if(条件)? a else b ，相当于 java 中的三元运算符：条件? 表达式 1：表达式 2<br> if-else if-else<br>注意，如果将 if 作为表达式（返回值或者将它赋给变量），该表达式需要有 else 分支。<br>6.2. when<br>when 用于代替 switch 操作符，格式如下：<br>when(表达式){<br>目标值 1-&gt;{语句 1}<br>…<br>目标值 n-&gt;{语句 n}<br>else -&gt;{<br>语句 n+1<br>}<br>}<br>when 语句将表达式的值与每个目标值进行匹配，如果找到匹配的值，会执行相应“-&gt;”后<br>面的语句(若只有一条语句，{}可以省略)，执行完后自动 break。若没有匹配值，会执行 else 后面<br>的语句。when 既可以被当做表达式使用，也可以当做语句使用。若当成表达式使用，符合条件的分<br>支的值就是整个表达式的值，若当成语句使用，则忽略个别分支的值。<br>分支条件不仅仅局限于常量，可以是任意表达式，例如：<br> 多个分支放在一起，用逗号分隔<br>0,1-&gt;print(“xxx”)<br> 任意表达式<br>parseInt(s)-&gt;print(“xxx”)<br> 一个值在（in）或不在（!in）一个区间或集合中<br>when(x){<br>in 1..10 -&gt;print(“xxx”) //x 的值是在[1,10]之间则匹配<br> 一个值是（is）或不是（!is）一个特定类型的值<br>when(x){<br>is String-&gt;print(“xxx”) //x 是 String 类型的值则匹配<br>注意，如果 when 作为一个表达式使用时，必须有 else 分支。<br>若 when 后面没有表达式，那么所有的分支条件都是简单的布尔表达式，当一个分支条件为<br>真时，可执行该分支后面的语句。例如：<br>when{<br>a&gt;b -&gt; print(“a 大于 b”)<br>a&lt;b -&gt; print(“a 小于 b”)<br>else -&gt; print(“a 等于 b”)<br>}<br>6.3. while 循环/do-while 循环（与 java 一致，略）<br>6.4. for 循环</p>
<p>1) for 循环语句<br>for 循环可以对任何提供了迭代器的对象进行遍历，相当于 C#中的 foreach，python 中的 for<br>in，语法格式如下。<br>for( 循环变量 in 循环条件 ) { 语句 }<br>循环变量不需要定义成变量形式，直接给出变量名即可，表示是循环条件中的某个变量。<br>所以，for 可以遍历任何提供了迭代器的对象。例如迭代一个数组。<br>val array=arrayOf(“a”,”b”,”c”)<br>for( i in array) println( i ) //分行输出 a，b，c<br>循环条件也可以是一个区间，若在数字区间上迭代，可使用区间表达式，例如：<br>for( i in 1..3 )<br>for( i in 6 downTo 0 step 2 )<br>若要遍历数组或 list 的索引(注意，不是直接取值)可以进行如下操作：val array=arrayOf(“a”,”b”,”c”)<br>for( i in array.indices ) println( i ) //分行输出 0,1,2<br>2) forEach 语句<br>[1] 普通的 forEach 语句<br>格式：<br>调用者.forEach(){<br>println(“ i = $it “)<br>}<br>调用者可以是数组或集合,it 是一个特定名称的值，代表数组或集合中的元素。表示在循环中<br>迭代调用者中的元素。例如：<br>var array =arrayOf(“a”,”b”,”c”)<br>array.forEach(){<br>println(it) //分行输出 a，b，c<br>println(“$it”) //注意，println($it)是错误的<br>}<br>[2] 带索引的 forEachIndexed 语句<br>格式：<br>调用者. forEachIndexed(){<br>index,it-&gt;println(“ 索引=$index， 元素 = $it “)<br>}<br>index 和 it 都是特定名称的值，index 代表数组/集合的索引，it 代表数组/集合索引对应的元<br>素。表示在循环中迭代调用者的索引和元素。<br>例如：<br>fun main() {<br> var array =arrayOf(“a”,”b”,”c”)<br> array.forEachIndexed(){<br> index,it-&gt;println(“索引=$index,元素=$it”)<br> }<br>}<br>输出：<br>索引=0,元素=a<br>索引=1,元素=b<br>索引=2,元素=c<br>6.5. break 与 continue<br>Kotlin 中有三种结构化的跳转表达式： return：默认从最直接包围它的函数或者匿名函数返回。<br> break：终止最直接包围它的循环。<br> continue：继续下一次最直接包围它的循环。<br>注意：在 when 中需要 break，匹配项执行完后会自动终止 when 语句。</p>
<h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h1><p>7.1. 函数式编程<br>函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演<br>算（lambda calculus），而且 λ 演算的函数可以接受函数当作输入（参数）和输出（返回值）。<br>函数式编程具有如下特征：<br> 一等函数支持，函数也是一种数据类型，可以作为参数传入另一个函数中，同时函数也可<br>以返回一个函数。<br> 纯函数和不变性，纯函数指的是没有副作用的函数，即函数不去改变外部的数据状态。<br> 函数组合，在面向对象的编程中是通过对象之间发送消息来构建程序逻辑的。而在函数式<br>编程中是通过不同函数的组合来构建程序逻辑的。<br>7.2. 函数的定义<br>fun 函数名称( [参数名称：参数类型，参数名称：参数类型] ）：返回值类型 {<br>执行语句<br>…<br>return 返回值<br>}<br>函数参数使用 pascal 表示法，即 name:type，每个参数必须有显式的类型。参数之间用逗号<br>隔开。<br>注意：不返回任何类型的值，定义为：Unit（无类型），类似于 Java 中的 void。当函数的返<br>回值类型为 Unit 时，可以省略不写 Unit。<br>例如：<br>fun sum( str:String ):Int{<br>……<br>}<br>函数也可以当做变量来使用，例如：<br>val sum=fun(x:Int,y:Int):Int{return x+y} //将一个匿名函数赋给 sum<br>7.3. 函数的分类</p>
<p>1) 顶层函数<br>顶层函数又称为包级别函数，可以直接放在某一个包中，而不像 Java 一样必须将函数放在<br>某一个类中（类似 python）。在 Kotlin 中，函数可以独立存在，例如经常用的 main()函数。顶层函数在被调用时，如果在同一个包中，可直接调用，如果在不同的包中，需要导入对应的包。<br>2) 成员函数<br>成员函数是在类或对象内部定义的函数，例如在类中定义的函数：<br>class 类名{<br> fun 函数名(){<br> 函数体<br> }<br>}<br>在其他地方调用此类中的函数时，需要通过：“类的实例.成员函数()”的形式<br>3) 局部函数（嵌套）<br>局部函数又称嵌套函数，主要是在一个函数的内部定义另一个函数。语法格式如下：<br>fun 函数名 1(){<br> fun 函数名 2(){<br> 执行语句<br> }<br> 执行语句<br>}<br>局部函数可以访问外部函数的局部变量，并且在外部函数中可以调用其内部的局部函数。<br>7.4. 函数的参数<br>函数的参数分为默认参数、具名参数以及可变参数 3 种。</p>
<p>1) 默认参数<br>在定义函数时，可以给函数中的每一个形参指定一个默认的值。在调用是，当省略相应的参<br>数时使用默认值。语法格式如下：<br>fun 函数名(形参 1: 类型,形参 2: 类型= 默认值, …) {<br>函数体<br>}<br>例如：<br>fun introduce(name: String = “江小白”, age: Int) {<br>println(“姓名：$name”) //打印传递的姓名<br>println(“年龄：$age”)<br>}<br>fun main(args: Array<String>) {<br>ntroduce(age = 20) //调用 introduce()函数，并指定函数中的形参与实参<br>}<br>在上述代码中，将 introduce()函数传递的形参 name 赋了一个默认的值“江小白” 。此时在 main()函数中调用 introduce()函数时，可以不用指定形参 name 的实参，直接传递形参 age<br>的值即可。若在调用时制定了 name 的值，那以此值为准。<br>2) 命名参数<br>在调用函数时显示指定形参的名称，这样即使形参和实参的顺序不一致也不会有任何影响，<br>因为已经明确指定了每个形参对应的实参。调用语法格式如下：<br>函数名称(形参 1=实参 1,形参 2=实参 2,形参 3=实参 3…)<br>例如：<br>fun info(name: String, age: Int) {<br>println(“姓名：$name”)<br>println(“年龄：$age”)<br>}<br>fun main(args: Array<String>) {<br>info(name = “江小白”, age = 20) //调用 info()函数，指定函数中的形参与实参<br>}<br>在 main()函数中调用了 info()函数，在调用的同时指定了该函数的形参和实参，在调用函数<br>info()时，传递的两个参数的顺序可以不固定，可写为 info(name = “江小白”, age = 20)，也可<br>写为 info(age = 20, name = “江小白”)<br>3) 可变参数<br>可变参数指的是参数类型确定但个数不确定的参数，可变参数通过 vararg 关键字标识，可<br>以将其理解为数组。可变参数通常声明在形参列表中的最后位置，如果不声明在最后位置，那么<br>可变参数后面的其他参数都需要通过命名参数的形式进行传递。<br>例如：<br>fun sum(name: String, vararg scores: Int) {<br>var result = 0<br>scores.forEach { //forEach 为迭代 scores 中的元素<br>result += it //it 代表 scores 中的每个元素<br>}<br>rintln(result)<br>}<br>fun main(args: Array<String>) {<br>sum(“江小白”, 100, 99, 98, 100, 96)<br>}<br>在上述代码中， sum()函数定义了一个可变参数 scores。由于可变参数可以当作数组处理，<br>因此可以使用 forEach 循环遍历 scores 中的值。<br>当在 main()方法中调用 sum()函数时，需要传递一个 String 类型的实参，以及任意多个 Int<br>类型数据。由于可变参数实质上就是数组，因此，可以直接使用数组存放可变参数，在传递时使用数组<br>即可，例如：<br>var scores: IntArray = intArrayOf(100, 99, 98, 100, 96)<br>sum(“江小白”, <em>scores)<br>注意：在实参中传递数组时，需要使用“<em>”前缀操作符，意思是将数组展开，并且它只能展<br>开数组，不能展开集合。<br>Kotlin 中可变参数规则：<br>• 可变参数可以出现在参数列表的任意位置；<br>• 可变参数是通过关键字 vararg 来修饰；<br>• 可以以数组的形式传递实参，使用时，需要使用“</em>”前缀操作符。<br>Java 中可变参数规则：<br>• 可变参数只能出现在参数列表的最后；<br>• 用“…”代表可变参数，“…”位于变量类型与变量名称之间；<br>• 调用含有可变参数的函数时，编译器为该可变参数隐式创建一个数组，在函数体中以数组<br>的形式访问可变参数。<br>7.5. 函数重载<br>函数名相同，形参列表不同的函数，就被称为函数重载，不推荐重载形参个数可变的函数。<br>注意：函数的重载与函数的返回值类型无关，只需要同时满足两个条件，一是函数名相同，<br>二是参数个数或参数类型不相同即可。<br>7.6. 单表达式函数<br>如果函数体中只有一行代码，则可以把包裹函数体的花括号{}替换为等号“=” ，把函数体<br>放在等号“=”的后面，这样的函数称为单表达式函数。例如：<br>fun add(a:Int,b:Int):Int{<br>return a+b<br>}<br>上述函数只有一行，且返回一个表达式，因此可以转换为表达式函数，转换后如下：<br>fun add(a:Int,b:Int):Int=a+b //函数返回的值是表达式 a+b 的值<br>在上述语法格式的基础上，单表达式还可以省略函数的返回值类型，结果如下：<br>fun add(a:Int,b:Int) =a+b //编译器会根据函数的返回值进行推断<br>7.7. Lambda 表达式<br>7.7.1. 概述<br>Lambda 表达式就是一个匿名函数（表达式、函数和逗号运算符的综合），它是函数式编程的<br>基础。函数式编程的思想是将计算机运算视为函数的计算，并且计算的函数可以接收函数作为输<br>入参数或者当作返回值来使用。格式：<br>{ params -&gt; expressions }<br>params 表示参数列表，expressions 表示具体实现，可以是单行语句，也可以是多行语句。<br>返回值：<br>注意：Lambda 表达式所表示的函数都是有返回值的，返回值的值和类型和都是由方法体中<br>最后一条语句决定，但在定义的时候省略了返回值的类型，因为返回类型可以自动推断出来。<br>Lambda 表达式的特点总结如下：<br> Lambda 表达式必须用大括号括起来<br> 其参数(如果存在)在 -&gt; 之前声明(参数类型可以省略)<br> 函数体(如果存在)在 -&gt; 后面<br>7.7.2. 无参数表达式<br>在定义无参 Lambda 表达式时，只需要将函数体写在“{}”中，函数体可以是表达式或语句<br>块，语法格式如下：<br>{函数体}<br>调用格式如下：<br>{函数体}()<br>例如：<br>fun main(args: Array<String>) {<br>{<br>println(“无参数 Lambda 表达式”) //这一行就是函数体<br>}()<br>}<br>上面代码中，{ println(“无参数 Lambda 表达式”) } 为无参数的 lambda 表达式，后面加括<br>号就此表达式的调用，Lambda 表达式被调用后，便会执行表达式中的函数体。<br>7.7.3. 有参数表达式<br>定义有参数的 Lambda 表达式时，需要指定参数名称以及参数类型，参数之间使用英文逗号<br>“,”分隔。Lambda 表达式中的“-&gt;”用于指定参数或数据的指向，语法格式如下：<br>{参数名:参数类型,参数名:参数类型 … -&gt;函数体}<br>注意：<br> 参数不需要括号<br> 若函数体是多行，不能加{}（加了{}，函数体变成了一个无参数的 lambda 表达式）<br>调用方式与无参 Lambda 表达式类似，在表达式后面加“()”,但是“()”中需要填写函数的<br>参数，格式如下：<br>{参数名:参数类型,参数名:参数类型 … -&gt;函数体}(参数 1，参数 2… )7.7.4. 单个参数的隐式名称 it<br>若一个 lambda 表达式只有一个参数，可以不用声明唯一的参数，并忽略符号“-&gt;”，该参数<br>会隐式声明为 it，例如：<br>ints.filter{ it&gt;0 } // { it:Int –&gt;it&gt;0}<br>7.7.5. 将 Lambda 表达式赋值给一个变量，通过变量来直接调用。<br>fun main(args: Array<String>) {<br>val sum={a:Int, b:Int -&gt; a+b}<br>print( sum(6,8) ) //通过 sum 变量调用 lambda 表达式<br>}<br>7.7.6. 传递末尾的 Lambda 表达式<br>在 kotlin 中有一个约定：如果函数的最后一个参数是函数，那么作为实参传入的 lambda 表<br>达式可以放在圆括号之外。例如：<br>val product=items.fold(1){acc,e-&gt;acc<em>e}<br>这种语法也称为拖尾 lambda 表达式。<br>如果该 lambda 表达式是调用时的唯一参数，那么圆括号也可以省略，例如：<br>run{ print(“xxx”)} //{ print(“xxx”)}作为 run()函数的唯一参数<br>另外，如果在默认参数（赋值的形参）之后的最后一个参数是 lambda 表达式，那它既可以<br>作为具名参数在括号内传入，也可以在括号外传入。例如：<br>fun foo(bar: Int=0, baz: Int=1, qux:() -&gt;Unit){ /</em>……</em>/ } //参数 qux 为 lambda 表达式<br>foo(1) { println(“hello”) } // baz=1，lambda 表达式在括号外<br>foo(qux = { println(“hello”) }) // 前两个参数使用默认值，qux 使用具名参数，且在括号内<br>foo { println(“hello”) } // 前两个使用默认值，lambda 在括号外，且由于只有一个参数，<br>所以可以省略括号<br>7.7.7. lambda 表达式的应用</p>
<p>1) 函数式接口隐式转换为 lambda 表达式<br>button.setOnClickListener { [view : View -&gt;]<br> Toast.makeText(this,”Hello World”,Toast.LENGTH_LONG).show()<br>}<br>参考 “匿名内部类”<br>7.8. 匿名函数<br>省略名称的函数，例如：<br>fun(x:Int, y:Int):Int = x+y //fun 后面省略了函数名<br>匿名函数看起来与一个常规函数的声明类似，只是名称省略了，其函数体可以是表达式（上一个函数）或代码块（下面的函数）。<br>fun(x:Int, y:Int):Int {<br>return x+y<br>}<br>与 lambda 的区别：<br> 匿名函数参数作为实参时，必须在括号内传递。允许将函数留在圆括号外的简写语法仅适<br>用于 lambda 表达式。<br> 大部分情况下，匿名函数和 lambda 表达式几乎可以通用，推荐使用 lambda 表达式。<br>但匿名函数可以使用 return 关键字，而 lambda 表达式不行。<br>7.9. 函数类型</p>
<p>1) 表示函数类型的元素有：参数个数，参数类型，返回值类型。格式为：<br>(参数类型,参数类型,…)-&gt;返回类型<br> 参数类型列表确定参数个数和类型，可以为空，但圆括号不能少，例如：()-&gt;A<br> 返回类型必须显式声明，Unit 类型也不能省略。<br>2) 函数类型为可空类型的写法：<br>var funOrNull:( (Int, Int) -&gt; Int )? = {…}<br>即在非空函数类型基础上，外层添加括号，右侧添加 ? , 该函数类型就变成了可空函数类型；<br>如果不加括号，那就是函数类型中，函数的返回值为可空的情况。<br>可以通过使用类型别名给函数类型起一个别称，例如：<br>typealias ClickHandler = (Button, ClickEvent)-&gt;Unit<br>3) Kotlin 中函数类型有三种实例化方式（初始化函数变量）：<br> 通过函数名，可以通过 :: Name 或者 obj:: Name，表示把一个函数当做一个参数，传<br>递到另一个函数中进行使用，即引用一个函数。<br> 匿名函数类型。<br> Lambda 表达式。<br>例如：<br>//定义函数 get<br>fun get(i:Int):String{<br>return “${i<em>3}”<br>}<br>fun main(){<br>//使用带名称的函数<br>val func3:(Int)-&gt;String = ::get<br>//使用匿名函数<br>val func1:(Int)-&gt;String = fun(i:Int):String{ return “${i</em>3}” }// 使用 Lambda 表达式实例化<br>val func2:(Int)-&gt;String = { i:Int-&gt; “${i*3}” }<br>}<br>7.10. 高阶函数<br>高阶函数是将另一个函数用作参数或者返回值的函数。Kotlin 可以以 lambda 或函数引用作<br>为参数或返回值，所以，任何以 lambda 或函数引用作为参数或返回值的都是高阶函数。</p>
<p>1) Lambda 表达式作为其他函数的参数<br>//普通函数类型参数的高阶函数<br>fun caculate(operation: (Int, Int) -&gt; Int) { //形参 operation 参数为函数类型<br>val result = operation(2,3) //通过 operation 调用函数<br>println(“result is $result”)<br>}<br>caculate { a,b -&gt; a+b } //实参为{ a,b -&gt; a+b }的 lambda 函数<br>caculate { a, b -&gt; a* b} //实参为{ a,b -&gt; a*b }的 lambda 函数<br>从上述例题可以看到，定义了高阶函数 caculate，其参数为一个 lambda 函数，调用 caculate<br>时，根据传入不同的 lambda 函数作为参数，caculate 内部进行不同的调用，并返回不同的值。<br>//参数为可空的函数类型<br>fun foo(callback: (() -&gt; Unit)?) {<br> if (callback != null) //必须显式检查 null<br> callback()<br>}<br>//更为常用的是采用安全调用符：<br>fun foo(callback: (() -&gt; Unit)?) {<br> callback?.invoke()<br>}<br>2) Lambda 表达式作为其他函数的返回值<br>函数的返回值为另外一个函数。所以定义函数时，需要指定一个函数类型作为返回类型，函<br>数体中需要一个包含 lambda 的 return 语句。<br>fun foo(): (Int,Int)-&gt;Int{<br>return { Int a,Int b-&gt; a+b }<br>}<br>7.11. 内联函数<br>被“inline”修饰符修饰的函数称为内联函数，当函数被声明为 inline 时，函数体会被直接替<br>换到函数被调用的地方，而不是被正常调用。<br>例如：public inline fun xxx(){ … }</p>
<h1 id="8-可见性修饰符"><a href="#8-可见性修饰符" class="headerlink" title="8. 可见性修饰符"></a>8. 可见性修饰符</h1><p>在 Kotlin 中有这四个可见性修饰符：private、protected、internal 和 public。如果没有显<br>式指定修饰符的话，默认可见性是 public。<br>8.1. 包内元素<br>函数、属性、类、对象、接口可以在顶层声明，即直接在包内声明，例如：<br>package foo<br>fun baz(){ ……} //顶层函数<br>class Bar{ ……}<br>他们的可见性为：<br>public 默认可见性，其他文件和包皆可访问<br>private 只会在声明它的文件内可见；<br>internal 它会在相同模块内可见；<br>protected 不适用<br>注意：要使用另一包中可见的顶层声明，仍需将其导入。<br>8.2. 类和接口中的元素<br>public 默认可见性，能访问类/接口，即可访问此元素<br>private 类/接口内部（包含其所有成员）可见<br>internal 能见到类声明的本模块内可访问<br>protected 本类和子类可访问<br>外部类不能访问内部类的 private 成员<br>覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 类<br>8.3. 局部变量<br>局部变量、局部函数和局部类不能有可见性修饰符<br>8.4. 模块（intenal）<br>可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说，一个模块是编译在<br>一起的一套 Kotlin 文件：<br> 一个 IntelliJ IDEA 模块<br> 一个 Maven 项目<br> 一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）<br> 一次<kotlinc>Ant任务执行所编译的一套文件9. 类</p>
<h1 id="9-类"><a href="#9-类" class="headerlink" title="9. 类"></a>9. 类</h1><p>9.1类的定义<br>Kotlin 类的成员可以包含：<br> 构造函数和初始化块<br> 属性<br> 函数<br> 嵌套类和内部类<br> 对象声明<br>注意，kotlin 类中是没有字段的概念的，定义的变量都是属性。<br>类默认是 public final 的。即 public final class xxx，不能被继承。<br>例如：<br>class name head{<br>…<br>}<br>类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类<br>头与类体都是可选的；<br>如果一个类没有类体，则可以省略花括号，例如：class Empty<br>通常，一个类的内容按照以下顺序排列：<br> 属性声明与初始化块<br> 次构造函数<br> 方法声明<br> 伴生对象<br>9.2. 构造函数</p>
<p>1) 主构造函数<br>在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类<br>头的一部分：它跟在类名后，用关键字 constructor 定义（而不是与类名一致），例如：<br>class Person constructor(name:String){ …… } //name 为构造函数的参数<br>如果主构造函数在 constructor 前面没有任何注解或者可见性修饰符，可以省略 constructor<br>关键字。例如：<br>class Person(var name:String){ …… }<br>class Person public constructor(var name:String) { …… }<br>注意：主构造函数不包含代码，代码放到以 init 关键字作为前缀的初始化块中。在实例化期<br>间，初始化块按照它们出现在类体中的顺序执行，且初始化块可以分割后与属性初始化器交织在<br>一起。<br>例如：class testDemo(name:String){<br>val firstProperty=”First property:$name” //属性初始化器<br>//主构造函数初始化块<br>init {<br>println(“First initializer block that is prints ${name}”)<br>}<br>val len=name.length //属性初始化器<br>//主构造函数初始化块<br>init{<br>println(“Second initializer block that is ${ len }”) //若前面已定义属性，此处可用<br>}<br>}<br>fun main(){<br>testDemo (“hello”)<br>}<br>注意：<br> 主构造函数的参数可以在初始化块中使用，也可以在类体内声明的属性初始化器中使用。<br> 一个非抽象类没有声明任何（主或次）构造函数，默认有一个不带参数的主构造函数。<br> 构造函数默认为 public<br>2) 次构造函数<br>在类体内，前缀为 constructor 的构造函数。例如：<br>class Person{<br>constructor(xxx){ … }<br>}<br>注意，如果类存在主构造函数和次构造函数，次构造函数必须通过 this 函数调用主构造函数。<br>并且主构造函数的参数个数必须小于新定义的次构造函数中参数的个数。如果一个类没有定义主<br>构造函数，次级构造函数就不必显式调用主构造函数（会自动隐式调用）。<br>this()函数作用为调用本类的构造函数，格式：<br>次构造函数:this(参数列表)<br>调用方式有如下两种：<br> 方式 1 直接调用：次构造函数主构造函数<br>class Con(name: String) { //主构造函数，参数为 name<br>var age = 0; //属性<br>var name:String //属性<br>init{ //主构造函数初始化块<br>this.name=name}<br>//次构造函数，直接委托主构造函数，参数名与主构造函数不需要一致，各管各的<br> constructor(na: String, age: Int) : this(na) {<br> this.age = age;<br> println(“次构造函数，$name ， $age”)<br> }<br>}<br>fun main() {<br>var tt=Con(“jack”,22)<br>}<br> 方式 2 间接调用：次构造函数次构造函数…主构造函数<br>class Con(name: String) {<br>var age = 0<br>var name:String?=null<br> var sex:Char?=null<br>init{ //主构造函数，参数为 name<br>this.name=name<br> println(“主构造函数，$name”)<br>}<br>//此次构造函数直接调用主构造函数<br> constructor(jackname: String, age: Int) : this(jackname) {<br> this.age = age;<br> println(“次构造函数 1，$name ， $age”)<br> }<br>//此次构造函数间接调用上面的次构造函数<br> constructor( johnname:String, age:Int, sex:Char ) : this(johnname,age) {<br> this.sex = sex;<br> println(“次构造函数 2，$name ， $sex”)<br> }<br>}<br>fun main(){<br> var t2=Con( “john”, 22, ‘m’ )<br>}<br>运行结果为：<br>主构造函数，john<br>次构造函数 1，john ， 22次构造函数 2，john ， m<br>可以看到，执行的顺序为：主构造函数直接调用的次构造函数间接调用的次构造函数<br>9.3. 创建类实例（对象）<br>kotlin 没有 new 关键字，创建实例时，直接调用构造函数即可。例如<br>val con=Con(“jack”) //创建对象<br>如果有多个构造函数，会根据不同的参数自动选择调用相应的构造函数<br>val con=Con(“jack”,22)<br>val con=Con(“jack”,22,’m’)<br>9.4. 属性</p>
<p>1) 定义与初始化<br>在 java 中，字段和其访问器的组合被叫做属性，在 kotlin 中的属性自动包含字段和访问器方<br>法，不再需要手动生成。<br>在类中声明一个属性和声明一个变量一样，使用 val 和 var。<br> val 是只读属性，生成一个字段和一个简单的 getter<br> var 是可写属性，生成一个字段 一个 getter 方法和一个 setter 方法<br>例如：<br>class Person{<br>val name:String = “只读属性” //生成一个字段和一个简单的 getter<br>var age:Int=20 //读写属性，生成一个字段，一个 getter 和一个 setter<br>}<br>另外，可以从主构造函数(次构造函数不可以)的参数中声明属性，格式：<br>//注意：在构造对象时，必须要有签名一致的参数来初始化属性<br>class Person( val/var 属性名:类型 , … ){ /<em>……</em>/ }<br>可以看到，其与参数的区别是有 val/var 修饰符。<br>例如：<br>class Con(var name: String, var age:Int) { //两个属性<br> fun show(){<br> println(“$name，$age”) //输出属性值<br> }<br>}<br>fun main(){<br> var t2=Con(“john”,22) //参数签名必须与属性签名一致<br> t2.show()<br>}<br>综上所述，属性的定义与初始化方法有如下三种： 主构造函数内定义属性，使用传入的参数初始化属性<br> 类体内定义属性，同时初始化<br> 类体内定义属性，init 块里初始化<br>lateinit 修饰符：kotlin 中的属性都是需要初始化值的（除非设置为可空类型），lateinit 表明<br>这个属性暂时不需要初始化（但是记得一定要在构造方法中初始化，不然还是会报空引用的异常），<br>会推迟到构造方法后调用。使用 lateinit 应注意：<br> lateinit 只能应用于 var 声明的属性<br> lateinit 不可以修饰原始数据类型（Byte，Char，Short ,Int，Long，Float，Double）<br> 委托中的 by lazy 则要求变量为 val<br>2) 属性访问<br>要访问属性，只需要通过名称来对它进行引用即可，格式：<br>对象.属性<br>例如：<br>val con=Con(“jack”,22,’m’)<br>con.name、con.age、con.sex<br>对于 ral 属性，只能取值，不能赋值，var 可以进行任意读取。<br>3) 自定义属性访问器<br>如果定义了一个自定义的 getter/setter 访问器，那么每次访问该属性时，都会自动调用它。<br>getter()对应 Java 中的 get()函数，setter()对应 Java 中的 set()函数。不过注意的是，不存在<br>Getter()与 Setter()，这只是 Kotlin 中的叫法而已，真是的写法，还是用 get()、set()。<br>例如：<br>var pro =“a”<br>get()=field<br>set(value) {<br>field = value<br>}<br>value 是 Koltin 写 setter()函数时其参数的默认名称，也可以换成其他名称。field 代表这<br>个属性本身。<br>9.5. 继承</p>
<p>1) 概述<br>在 Kotlin 中所有类都有一个共同的超类 Any（在程序运行时，Any 类会自动映射为 Java<br>中的 java.lang.Object 类）。Any 有三个方法：equals()、hashCode()与 toString()。因此，Kotlin<br>所有类都定义了这些方法。<br>如需声明一个显式的超类，在类头中把超类初始化（类似 C++的子类构造函数的书写方式）<br>放到冒号之后，例如：class Derived(p:Int):Base(p) //注意：是超类初始化<br>由于 kotlin 中的类默认是 public final 的，所以不能被继承。因此，某个类作为超类被继承<br>时，需要在此类前面加上 open 关键字。<br>例如：<br>open class Parent{ //基类必须有 open 修饰<br> fun show(){<br> println(“hello Parent”)<br> }<br>}<br>//注意，即使基类没有定义构造函数，但还有隐式的构造函数，所以此处必须初始化，即调<br>用构造函数进行初始化<br>class Child:Parent(){}<br>fun main(){<br> var c=Child()<br> c.show()<br>}<br>如果派生类有一个主构造函数，其基类必须用派生类主构造函数的参数就地初始化。如果派<br>生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另<br>一个构造函数做到这一点。注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构<br>造函数。<br>继承注意点：<br> 一个类只能继承一个父类，不能继承多个父类，即单继承<br> 多个类可以继承一个父类<br> 多层继承也是可以的，即一个类的父类可以再去继承另外的父类，例如 C 类继承 B 类，<br>而 B 类又可以去继承 A 类，这时，C 类也可称作 A 类的子类。例如：<br>open class A {}<br>open class B : A() {} //类 B 继承类 A，类 B 是类 A 的子类<br>class C : B() {} //类 C 继承类 B，类 C 是类 B 的子类，同时也是类 A 的子类<br> 子类继承父类时会自动继承父类中定义的方法和属性<br>2) 方法重写<br> 在子类中重写的方法与在父类中被重写的方法必须具有相同的方法名、参数列表、返回值<br>类型<br> 重写的方法需要使用“override”关键字标识。<br> 在子类中重写的属性与在父类中被重写的属性必须具有相同的名称和类型，并且重写的属<br>性前边也需要使用“override”关键字标识。<br> 在父类中需要被重写的属性和方法前面必须使用“open”关键字来修饰 重写基类中使用默认值的方法时，重写方法中必须省略默认参数值。例如：<br>open class A{<br>open fun foo(i:Int=10){ … }<br>}<br>class B:A(){<br>override fun foo(i:Int){ … }<br>}<br>3) super 关键字<br>当子类重写父类的方法后，通过子类对象将无法直接访问父类被重写的方法，需通过 super<br>关键字才能访问。格式如下：<br>super.成员变量<br>super.成员方法( [ 形参 1, 形参 2… ] )<br>9.6. 抽象类<br>被 abstract 关键字修饰的类(class) 被称为抽象类。注意，当一个类中包含了抽象方法，该<br>类必须定义为抽象类。格式：<br>abstract class className{<br> abstract fun funName()<br>}<br>包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法。另外，抽象类不<br>可以被实例化。<br>抽象方法：必须使用 abstract 关键字修饰，没有方法体的方法；且默认是 open 方法，例如：<br>abstract fun xxx()<br>被 abstract 关键字修饰的属性(var|val) 被称为抽象属性；抽象属性没有初始值，也没有<br>setter 和 getter 访问器。<br>抽象方法和抽象属性只能在抽象类中声明，它们和抽象类默认都是 open，不需要手动添加<br>open 修饰符。<br>9.7. 接口<br> 接口通过 interface 定义，格式：<br>interface 接口名称 [ : 继承接口 ]{<br>…<br>}<br> Kotlin 的接口可以既包含抽象方法的声明，也包含实现的方法（实现的方法类似 java 接<br>口中的 default 方法），实现的方法在实现类中不需要重写，可以直接调用。没有实现的<br>必须重写<br>例如：interface Interface1 {<br>fun bar() // 未实现<br>fun function1() { //已实现方法<br>println(“Interface1 function1 called”)<br>}<br>}<br>interface Interface2 {<br> fun function2() { //已实现方法<br> println(“Interface2 function2 called”)<br> }<br>}<br>class MyClass : Interface1, Interface2 {<br>override fun bar() { //实现 Interface1 中未实现的方法<br>// 方法体<br>}<br>fun myFunction() { //实现类中直接调用接口中已实现的方法<br>function1()<br>function2()<br>}<br>}<br>fun main(){<br> MyClass().myFunction()<br>}<br> 与抽象类不同的是，接口无法保存状态（即属性）。所以接口可以定义属性，但必须声明<br>为抽象的或提供访问器实现。在实现接口时，必须重写抽象属性。<br>例如：<br>interface MyInterface{<br>var name:String //name 属性, 默认实抽象的<br>//提供访问器实现的属性，不是抽象的，但是不能引用它们<br>val proImpl: String<br>get() = “foo”<br>}<br>class MyImpl:MyInterface{<br>override var name: String = “runoob” //必须重写抽象属性<br>}fun main(){<br> var myimpl=MyImpl()<br> myimpl.name=”new string” //可以引用，正常赋值<br> myimpl.proImp=”new proimpl” // 不可以引用，报错 “Unresolved<br>reference”<br> println(myimpl.name)<br> print(myimpl.proImpl)<br>}<br> 一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br> 函数式接口：有且仅有一个抽象方法的接口<br>函数式接口可以使用 lambda 方式实现。即函数式接口可以自动被隐式转换为 lambda<br>表达式。<br>函数式接口的 lambda 实现：<br>例 1：无参数的情况<br>button.setOnClickListener{ textView.setText(“新内容”) }<br>例 2：有参数的情况<br>TabLayoutMediator(tab,viewpage2){ tab: TabLayout.Tab, position:Int-&gt;<br>tab.setText(str_ary[position])<br>}<br>9.8. 常用类<br>9.8.1. 伴生对象(companion)<br>Kotlin 取消了关键字 static，也就无法直接声明静态成员，所以引入了伴生对象这个概念。<br>在对象声明的前面加上 companion 关键字就生成了伴生对象。作用就是为其所在的外部类模拟<br>静态成员。伴生对象是在类加载时初始化，生命周期与该类的生命周期一致。<br>注意：由于每个类中有且仅有一个伴生对象，因此也可以不指定伴生对象的名称，并且类的<br>各个对象可以共享伴生对象。所以，调用过程中，可以不需要伴生对象，而是通过外部类直接调<br>用伴生对象内的成员。<br>定义语法：<br>companion object [伴生对象名称] : [0~N 个父类型] {<br>……<br>}<br>伴生对象成员调用：<br>（1）有名称：调用方式为“类名.伴生对象名.成员名”或“类名.成员名” 。<br>（2）无名称：调用方式为“类名.Companion.成员名”或“类名.成员名” 。<br>特点： 每个类最多定义一个伴生对象；<br> 伴生对象相当于外部类的对象，可以直接通过外部类名访问伴生对象的成员；<br> 虽然伴生对象是为其所在对象模拟静态成员，但是伴生对象成员依然属于伴生对象本身的<br>成员，而不属于其外部类的成员。<br>例如：<br>class OuterClass {<br> companion object Co{<br> val name = “伴生对象属性”<br> fun companionFun() {<br> println(“调用伴生对象方法”)<br> }<br> }<br>}<br>fun main() {<br> println(OuterClass.name) / println(OuterClass.Co.name)<br> OuterClass.companionFun() / OuterClass.Co.companionFun()<br> OuterClass.Co //通过伴生对象名称获取伴生对象本身<br>}<br>省略伴生对象名称后，如果想获取伴生对象本身，可以通过 Companion 获取，例如：<br> OuterClass.Companion //通过 Companion 获取伴生对象本身<br>9.8.2. 单例模式(object)<br>单例模式就是在程序运行期间针对该类只存在一个实例。就好比这个世界只有一个太阳一样，<br>假设现在要设计一个太阳类，则该类就只能有一个实例对象，否则就违背了事实。<br>在 Kotlin 中，单例模式是通过 object 关键字来完成的，通过 object 修饰的类即为单例类，<br>单例类在程序中有且仅有一个实例（即定义的类即是类又是此类的实例）。<br>例如：<br>object Singleton { //定义单例对象<br>var name = “单例模式”<br>fun sayHello() { … }<br>}<br>fun main(args: Array<String>) {<br>Singleton.name = “小太阳”<br>Singleton.sayHello()<br>}<br>注意，kotlin 中没有 static 类，所以，java 中的 static 类，在 kotlin 中用单例模式表示。9.8.3. 内部类(inner) 和嵌套类</p>
<p>1) 概念<br>嵌套类是指嵌套在其他类中的类，嵌套类不能访问外部类的成员。<br>内部类指的是在其他类中用 inner 标记定义的类，内部类能够访问外部类的成员。<br>Kotlin 中的内部类与嵌套类与 Java 中的类似，不同的是在没有任何修饰的情况下，定义在<br>一个类内部的类被默认称为嵌套类，如果想将它声明为一个内部类，则需要加上 inner 修饰符。<br>例如：<br>class Outer {<br>var name = “njucm” //外部类的属性<br>inner class Inner {<br>fun sayHello() {<br>println(“Hello！我叫$name。”) //内部类可以调用外部类的成员变量<br>}<br>}<br>}<br>2) 内部类中访问外部类对象<br>在 Android 开发中，若有内部类访问外部对象的需求，就不能采用 java 中采用 OutClass.this<br>的方式了。<br>在 Kotlin 中，访问外部类对象的方式为：this@OutClass，若访问外部对象的元素，字需要<br>在后面加上元素名即可，例如：<a href="mailto:this@OutClass.xxx">this@OutClass.xxx</a><br>例如，在 MainActivity 的内部类中访问 MainActivity 对象的代码如下：<br>class MainActivity : AppCompatActivity(){<br> override fun onCreate(savedInstanceState: Bundle?) {<br> …<br> button.setOnClickListener(ClickListener()) //绑定事件处理对象（新建对象）<br> }<br>//内部类实现接口，所以事件处理对象需用本类定义<br> inner class ClickListener : View.OnClickListener {<br> override fun onClick(v: View?) {<br>//注意：内部类访问外部对象，方法为：this@外部类名<br><a href="mailto:this@MainActivity.findViewById">this@MainActivity.findViewById</a><TextView>(R.id.textView).setText(“新内容<br>“)<br>// 由于内部类可以访问外部类的对象，所以简化为<br>// textView.setText(“新内容”)<br>}}}<br>注意： 在内部类内部访问外部对象，方法有两种，一种是当前程序所用的“this@外部类名”，还<br>有一种方法就是将对象定义为类变量，然后在 onCreate()方法中初始化，那所有的方法或<br>者内部类就都可以访问了。<br> 在内部类中才可以访问外部类的内容，所以，必须定义成内部类（inner），而不是嵌套类。<br>9.8.4. 匿名内部类<br>在 java 中创建匿名内部类，只需要把这个类直接 new 出来。例如最常见的设置一个按钮的<br>单击事件：<br>button.setOnClickListener( new View.OnClickListener() {<br>@Override<br>public void onClick(View v) { …… }<br>} );<br>上述代码中，通过 new OnClickListener(){}创建了一个 OnClickListener 接口的匿名的内部<br>类，此接口中唯一的方法就是 onClick(View v)。<br>Kotlin 中不需要 new，可以通过如下方法实现匿名内部类：</p>
<p>1) object 方式(单例模式)。<br>匿名内部类就使用一次，与单例模式正好吻合。且在创建单例模式时，可以省略类名。<br>例如，object MyClass:BaseClass{ … }，采用匿名类表示后为：object:BaseClass{ … }，省<br>略掉类名。所以，Java 中的 OnClickListener 接口的实现对象可以如下定义：<br>button. setOnClickListener ( object : OnClickListener{<br>override fun onClick (v: View?){ …… }<br>})<br>2) lambda 方式<br>上面单例模式中，setOnClickListener 函数的参数是一个单例，且它只有一个需要实现的抽<br>象方法。<br>这种有且仅有一个抽象方法、但可以有多个非抽象方法的接口称为函数式接口。在 kotlin 中，<br>可以通过 lambda 表达式来实现一个函数式接口的匿名对象。格式如下：<br>val myOnClickListener = OnClickListener{ //… }<br>上述代码通过 lambda 表达式显式的实现了一个函数式接口对象，即用 lambda 表达式代替<br>了 OnClickListener 接口中的唯一函数，参数的设定参考 lambda 表达式，若只有一个参数，可<br>省略，在函数体内用 it 访问。<br>下面就可以将此对象作为参数传入，代码如下。<br>button. setOnClickListener ( myOnClickListener )<br>但是，Kotlin 对于函数式接口对象作为参数这种情况，提供了更为简洁的方式，即<br>OnClickListener{ //… }生成对象的代码中，可以省略接口名，只保留{ //… } 部分，即<br>lambda 表达式，编译器会将 lambda 实参自动转换成一个 OnClickListener 实例（形参规定了接口类型）。<br>所以，对于函数式接口对象作为参数，一般的代码为：<br>button. setOnClickListener { //省略单个参数，若要使用，用 it 访问<br>…<br>}<br>上述代码中，setOnClickListener 的参数只有一个，且是简化的 lambda 表达式，按照 lambda<br>表达式的规定（如果该 lambda 表达式是函数调用时的唯一参数，那么函数的圆括号可以省略），<br>所以可以这样表示。<br>注意：若是纯粹定义一个函数式接口的实例，必须采用显式定义的方式，即：<br>val/var 属性 = 接口名{ //… }<br>9.8.5. 数据类(data)<br>在 Java 程序中，一般会用一些类来保存一些数据或者对象的状态，习惯上将这些类称为<br>bean 类或 entity 类或 model 类。在 Kotlin 中，专门处理这些数据的类被称为数据类，此类只包<br>含数据。<br>语法格式如下：<br>data class 类名(主构造函数列表) [:继承类和实现接口] [(/<em>类体</em>/)]<br>“类名(主构造函数列表)”是该类的主构造函数。定义一个数据类时，必须注意以下几点。<br> 数据类的主构造函数至少有一个参数，如果需要一个无参的构造函数，可以将构造函数中<br>的参数都设置为默认值。<br> 数据类中的主构造函数中传递的参数必须用 val 或 var 来修饰（属性）。<br> 数据类数据类默认为 final，不可以用 abstract、open、sealed 或 inner 关键字来修饰。<br> kotlin1.1 版本之后数据类可以继承其他类。<br> 编译器自动生成一些常用方法，如 equals()、hashCode()、toString()、componentN()、<br>copy()等。这些方法也可以进行自定义，例如若在类体中显式定义或继承自其基类，则不<br>会自动生成该函数。<br>在实际开发中，经常会用到数据类来存储一些数据信息，这些信息一般是通过该类的主构造<br>函数来传递的。<br>例如：<br>data class LoginUser(val username: String, val password: String) //不需要类体<br>数据类仅仅包含状态而没有任何可执行的操作，使用数据类替换普通的好处是 Kotlin 会自动<br>产生大量代码，从而省下大量重复性的工作。<br>9.8.6. 枚举类<br>枚举类型中，每个枚举常量都是一个此类型的对象，枚举常量用逗号分隔。定义枚举类型的<br>关键字是 enum。<br>枚举类有两个内置的属性：public final val name: String //枚举对象名<br>public final val ordinal: Int //下标位置<br>由于每个枚举常量都是当前枚举类的实例，因此这些实例也可以初始化。同时枚举支持构造<br>函数，因此可以使用构造函数来初始化。例如：<br>enum class MyWeek (val myname: String) {<br> //WU/WANG 为创建的实例，”吴强”等为属性 myname 的值<br> WU(“吴强”),<br> WANG(“王娟”)<br>}<br>fun main(){<br>val en=MyWeek.WU<br>print(en.myname) //输出：吴强<br>print(en.name) //输出：WU<br>print(en.ordinal) //输出：0<br>}<br>上述代码中，每个枚举都通过构造函数进行了初始化<br>9.8.7. 密封类(sealed)<br>kotlin 定义密封类的关键字是 sealed，例如：<br>sealed class SealedClass //与普通类的区别是增加了 sealed 关键字<br>当一个值只能在一个集合中取值，而不能取其他值时，此时可以使用密封类。在某种意义上，<br>密封类是枚举类的扩展，即枚举类型的值集合。<br>如果想要创建一个密封类必须满足以下两个条件：<br>（1）密封类必须用 sealed 关键字来修饰。<br>（2）虽然密封类可以有子类，但是由于密封类的构造函数是私有的，因此密封类的子类只能<br>定义在密封类的内部或者同一个文件中。<br>例如：<br>sealed class College{<br>class Nju : College(){}<br>class Njucm(){}<br>}<br>class Njnu : College()<br>上述代码中，定义了一个密封类 College，并在该类的内部定义了 Nju 子类；在同一个文件<br>中定义了 Njnu 子类；Njucm 类是该密封类的嵌套类<br>注意，密封类的非直接继承子类可以声明在其他文件中。<br>Kotlin 中密封类与枚举类的区别：密封类适用于子类可数的情况，而枚举类适用于实例可数的情况。<br>9.9. 扩展函数/属性<br>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p>
<p>1) 扩展函数<br>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：<br>fun receiverType.functionName(params):returntype{<br>…<br>}<br> receiverType：表示函数的接收者，即函数扩展的类/接口。除了这个，其他的都与定义<br>一个函数一样。<br>例如：<br>class Person(val name: String) {<br> fun eat() {<br> Log.i(name, “I’m going to eat”)<br> }<br>}<br>//扩展 Person 的方法<br>fun Person.drink() {<br>//方法中的 this 指的是调用这个扩展函数的当前对象<br>Log.i(“Person”, “${this.name}: I’m going to drink”)<br>}<br>扩展函数的调用：扩展函数调用与其他的实例函数相同，例如：<br>val person=Person(“alice”)<br>person.eat()<br>person.drink()<br>伴生对象的扩展:<br>伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调<br>用，例如：<br>class MyClass {<br>companion object{ … } //将被称为 “Companion”<br>}<br>fun MyClass.Companion.foo() {<br>println(“伴随对象的扩展函数”)<br>}<br>fun main(args: Array<String>) {MyClass.foo()<br>}<br>扩展函数和成员函数的区别：<br> 扩展函数不能打破扩展类的封装性，不能像成员函数一样直接访问内部私有函数和属性。<br>(原理:扩展函数访问实际上是类的对象访问，由于类的对象不能访问内部私有函数和属性，<br>自然扩展函数也就不能访问内部私有函数和属性了)<br> 扩展函数实际上是一个静态函数，处于类的外部，而成员函数则是类的内部函数。<br> 父类成员函数可以被子类重写，而扩展函数则不行<br>2) 扩展属性<br>扩展属性实际上就是提供某个属性访问的 set,get 方法，这两个方法是静态函数，同时都会传<br>入一个接收者类型的对象，然后在其内部用这个对象实例去访问和修改对象所对应的类的属性。<br>语法格式：<br>var/val<T> receiverType<T>.attributeName:T<br>get(){ … }<br>set(value){ … }<br>例如：<br>class Person(val name: String, val birthdayYear: Int) {<br> fun eat() {<br> print(name, “I’m going to eat”)<br> }<br>}<br>//通过扩展属性为 Person 增加读写的 age 属性<br>var Person.age: Int<br>get() = 2020 - this.birthdayYear<br>set(value){ … }<br>注意：扩展属性允许定义在类或者 Kotlin 文件中，不允许定义在函数中。<br>3) 扩展中的 this<br>在类的成员函数中，this 指向这个类的当前对象实例；这里的 this 指的是接收者对象，也就<br>是调用扩展函数时，在点号“.”之前指定的对象实例。<br>如果 this 没有限定符，那么它指向包含当前代码的最内层范围。如果想要指向其他范围内的<br>this，需要使用标签限定符。</p>
<h1 id="10-反射"><a href="#10-反射" class="headerlink" title="10. 反射"></a>10. 反射</h1><p>10.1. kotlin 和 java 的反射<br>Java 反射：<br>JAVA 反射机制是指：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的<br>功能称为 java 语言的反射机制。<br>那么如何能够完成上述功能呢，那就需要通过内存中的 Class 对象才能完成。下面来介绍如<br>何获取 Class 对象，并通过此对象完成上述功能。<br>获得 Class 对象有以下三个方法：</p>
<p>1) 通过 Object 类的 getClass()方法 ：public final Class&lt;?&gt; getClass()<br>例：<br>TextField t = new TextField();<br>Class c = t.getClass();<br>2) 通过“类.class”的形式<br>例：Class c = java.awt.Button.class;<br>3) 如果类名在编译期不知道, 但是在运行期可以获得,可以通过 Class 类的静态方法：<br>forName(string className)<br>例：Class cla=Class.forName(“cn.edu.njutcm.demo1.TestOne”);<br>注：className 必须为全名，也就是需包含包名<br>kotlin 的反射<br> kotlin 的 KClass 和 java 的 Class 可以看作同一个含义的类型，并且可以通过.java（转<br>换为 java 中的 Class）和.kotlin（转换为 kotlin 中的 KClass）属性在 KClass 和 Class 之<br>间互相转化<br> kotlin 的 KCallable 和 java 的 AccessibleObject 都可以理解为可调用元素。java 中构<br>造方法 Constructor 为一个独立的类型，而 kotlin 则统一作为 KFunction 处理<br> kotlin 的 KProperty 和 java 的 Field 不太相同。java 的 Field 通常仅仅指字段本身，<br>Field 具备了 getter 和 setter；kotlin 并没有字段的概念，她将属性分为了 KProperty 和<br>KMutableProperty ，当变量声明为 val 时，getter 即为 KProperty，当变量声明为 var<br>时，getter 和 setter 即为 KProperty 和 KMutableProperty<br>java 的反射操作步骤大概可以总结为以下几点：<br> 获取 Class<br> 通过 Class 获取 obj<br> 通过 obj 反射获取对象的成员、方法等<br>kotlin 的反射操作步骤大致和 java 相同，只是因为反射基本结构不同，所以在代码实现上有<br>稍微的不同。<br>10.2. kotlin 的反射操作<br> 获取静态已知 kotlin 类的引用（KClass）<br>使用“类名::class”或“实例::class(支持协变)”，类似于 java 中的“类名.class”，即采用新<br>符号“::”例如：<br>val c: KClass&lt; MyClass &gt;=MyClass::class / val c= MyClass::class<br>若要获得 java 类的引用，方法有：<br> 在 Kclass 实例上使用.java 属性<br> 实例.javaClass<br>例如：<br>val c=MyClass::class<br>c.java //或者将两条语句合并为：MyClass::class.java<br>或者：<br>MyClass().javaClass<br>这个在 android 的 Intent 初始化中使用频繁。例如：<br>var intent = Intent(this,SecondActivity::class.java)<br>startActivity(intent)<br>同理，在 java 中，若需要获取 kotlin 中的 Kclass，可以通过.kotlin 属性来获取。<br> Kotlin 运行时获取一个对象的 kclass 类：<br>对象.javaclass.kotlin<br>例如：val clazz = country4.javaClass.kotlin<br>11. 委托<br>委托模式也叫代理模式，是最常用的一种设计模式。在委托模式中，如果有两个对象参与处<br>理同一个请求，则接受请求的对象将请求委托给另一个对象来处理， 简单来说就是 A 的工作交<br>给 B 来做。<br>根据上述功能描述，委托模式中，有三个角色，需处理业务（即需要执行的函数，一般用接<br>口描述）、委托对象和被委托对象，如下图所示。<br>业务：它定义了通用的业务类型，也就是需要被代理的业务，通过接口或者抽象类来描述<br>委托对象：将具体业务委托给具体的委托对象<br>被委托对象：具体的业务逻辑执行者，需要实现请求接口/类中需要实现的函数。<br>委托模式是实现多继承的一个很好的替代方式。在 Kotlin 中，委托是通过 by 关键字实现<br>的，并且主要分为两种形式，一种是类委托，一种是属性委托。<br>业务</p>
<h1 id="11-委托对象-被委托对象"><a href="#11-委托对象-被委托对象" class="headerlink" title="11. 委托对象 被委托对象"></a>11. 委托对象 被委托对象</h1><p>11.1. 类委托<br>格式：<br>class 委托类( 被委托对象 : 被委托实现类 ) : 业务类 by 被委托对象<br>委托类中的参数是被委托对象，用来实现业务中的函数。后面的“业务类 by 被委托对象”<br>表示业务类中的事务将会由被委托对象实现，所以，委托类中不需要重写这些方法，但却可以调<br>用。<br>例如：大家都喜欢玩游戏，游戏中有相应的等级，越往上越难，如果老是升不上去，就想着<br>找个代练帮我们打。这就是委托，这里面，游戏是业务，委托对象是玩家，被委托对象是代练，<br>代练需要实现游戏的任务，所以代练需要实现业务中的方法。<br>用程序完成上述例题：<br>//角色 1：业务接口/类<br>interface Game{<br>//升级任务<br>fun upgrade()<br>}<br>//角色 2：/被委托类，即代练，实际上是他在玩游戏，即实现 Game 中的函数<br>class GameImpl(val name:String):Game{<br>//实现升级任务<br>override fun upgrade(){<br>println(“${name}正在努力帮你升级！”)<br>}<br>}<br>//角色 3：玩家，由于玩家要请代练来帮他玩游戏，所以需要委托代理<br>class GamePlayer(player:GameImpl):Game by player<br>//测试<br>fun main() {<br>val gameImpl = GameImpl (“好助手游戏代理”) //创建游戏代理对象<br>val gamePlayer = GamePlayer(gameImpl) //创建玩家对象<br>gamePlayer.upgrade()<br>}<br>从上述例题可以看到，实际是被委托类已经实现了业务，而其他类也需要执行业务，就不再<br>需要再次实现业务中的方法了，只需要委托给已经实现了业务的被委托类即可。所以参数中需要<br>有被委托对象，而在接口后面通过 by 关键字来说明实现此接口的对象。<br>11.2. 属性委托<br>属性委托是指一个类的某个属性值不是在类中直接进行定义，而是将其委托给一个代理类，从而实现对该类的属性进行统一管理。属性委托的语法格式如下：<br>val/var 属性名: 类型 by 表达式<br>例如：<br>import kotlin.reflect.Kproperty //注意：一定要导入<br>class Example {<br>var p: String by Delegate() //属性 p 委托到了一个 Delegate 实例<br>}<br>上述代码中，by 关键字前面是正常的属性定义，而后面的表达式是一个接收属性委托的委托<br>实例。<br>因为属性对应的 get()/set()会被委托给此委托类的 getValue()与 setValue()方法。因此被委<br>托类需要提供 setValue/getValue 这两个方法。如果是 val 属性，只需提供 getValue。如果是<br>var 属性，则 setValue/getValue 都需要提供。<br>//委托类的定义<br>class Delegate{<br>private var pro:String?=null //在属性赋值时，用来存放值<br>operator fun getValue(thisRef:Any?, property:KProperty&lt;<em>&gt;):String{<br>return “对象${thisRef},属性名称:${property.name},值${pro}” //输出属性值<br>}<br>operator fun setValue(thisRef:Any?, property: KProperty&lt;</em>&gt;,value: String){<br>pro=value //存放属性值<br>println(“在对象${thisRef}中，$value 被赋值给属性${property.name}”)<br>}<br>}<br>//测试<br>val e=Example()<br>e.p=”你好啊”<br>println(e.p)输出结果：<br>对象 Example@4c873330 中，你好啊 被赋值给属性 p<br>对象 Example@4c873330 中，属性名称:p,值:你好啊<br>参数：<br> thisRef：是属性所属的对象，必须与属性所有者类型相同（本例为 Example 类）或者是<br>它的超类型；<br> property：保存了对 p 自身的描述（注意不是属性值），必须是类型 KProperty&lt;*&gt;或其<br>超类型。<br> value：必须与属性同类型或者是它的子类型。<br>注意： setValue()方法和 getValue()方法前必须使用 operator 关键字修饰。<br> getValue()方法的返回类型必须与委托属性相同或是其子类<br>11.3. 延迟加载（by lazy）<br>Kotlin 标准库为几种有用的委托提供了工厂方法，包括延迟加载、可观察属性。<br>在 Kotlin 中，声明变量或者属性的同时要对其进行初始化，否则就会报异常，尽管可以定义<br>可空类型的变量， 但有时却不想这样做， 能不能在变量使用时再进行初始化呢？为此， Kotlin<br>中提供了延迟加载功能，即当变量被访问时才会被初始化，这样不仅可以提高程序效率，还可以<br>让程序启动更快。延迟加载是通过“by lazy”关键字标识的，延迟加载的变量要求声明为 val，<br>即不可变变量。延迟加载也是委托的一种形式，延迟加载的语法结构如下：<br>val 变量:变量类型 by lazy{<br>变量初始化代码<br>}<br>需要注意的是，延迟加载的变量在第 1 次初始化时委托方法会完整执行并记录结果，之后在<br>调用该变量时，都只会返回记录的结果。<br>例如：<br>fun main(args: Array<String>) {<br>val content by lazy {<br>println(“Hello”)<br>“World” //第 1 次初始化后，再次调用该变量时，只会输出最后一行代码内容<br>}<br>println(content)<br>println(content)<br>}<br>在上述代码中，通过 by lazy 定义了一个延迟加载变量 content，该变量中有一行打印语句<br>以及一个字符串，当调用该变量时，会发现只有第 1 次加载时会输出变量中的所有内容，而第 2<br>次加载时，只输出变量中的最后一行内容。<br>比如这样的常见操作，只获取，不赋值，并且多次使用的对象<br>private val mUserMannager: UserMannager by lazy {<br>UserMannager.getInstance()<br>}<br>lazy{}与 lateinit 的区别：<br> lateinit 只用于变量 var，而 lazy 只用于常量 val<br> lateinit只能在生命周期流程中进行获取或者初始化的变量，比如在Activity的onCreate()<br>方法中，且可以初始化多次。而 lazy 在第一次被调用时就被初始化，想要被改变只能重<br>新定义。11.4. 可观察属性<br>Delegates.observable()接受两个参数：初始值与修改时处理程序（handler）。 每当我<br>们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：<br>importkotlin.properties.Delegates<br>classUser{<br>varname:StringbyDelegates.observable(“<noname>“){<br>prop,old,new-&gt;println(“$old-&gt;$new”)<br>}<br>}<br>funmain(){<br>valuser=User()<br>user.name=”first”<br>user.name=”second”<br>}<br>如果你想截获赋值并“否决”它们，那么使用 vetoable()取代 observable()。在属性被赋新<br>值生效之前会调用传递给 vetoable 的处理程序。</p>
<h1 id="12-异常"><a href="#12-异常" class="headerlink" title="12. 异常"></a>12. 异常</h1><p>12.1. 概述<br>Kotlin 中所有异常类都是 Throwable 类的子孙类。每个异常都有消息、堆栈回溯信息以及可<br>选的原因。<br>12.2. try…catch…finally<br>异常捕获通过 try…catch 语句来实现，格式如下：<br>try {<br>//可能发生异常的语句<br>}catch (e: SomeException) { // e 的类型可以是 Exception 类或者其子类<br>// 对捕获的 Exception 进行处理<br>} finally{ //注意，若不需要，finally 模块可以省略<br>//若没有捕捉到异常，执行的代码<br>}<br>当 try 代码块中的程序发生了异常，系统会将这个异常的信息封装成一个异常对象， 并将这<br>个对象传递给 catch 代码块。catch 代码块中传递的 Exception 类型的参数是指定这个程序能够<br>接收的异常类型，这个参数的类型必须是 Exception 类或者其子类。<br>使用注意：<br> 可以有零到多个 catch 块 finally 块可以省略，但是 catch 与 finally 块至少应该存在一个。<br>12.3. throw<br>如果去调用一个别人写的方法时，是否能知道别人写的方法是否会有异常呢？这是很难做出<br>判断的。针对这种情况，允许在可能发生异常的代码中通过 throw 关键字对外声明该段代码可能<br>会发生异常，这样在使用这段代码时，就明确地知道该段代码有异常，并且必须对异常进行处理。<br>throw 关键字抛出异常的语法格式如下：<br>throw ExceptionType(“异常信息”)<br>上述语法格式是通过 throw 表达式来抛出一个异常， 这个表达式需要放在容易出现异常的<br>代码中，也可以作为 Elvis 表达式（三元表达式）的一部分，throw 后面需要声明发生异常的类<br>型，通常将这种做法称为抛出一个异常。<br>12.4. Nothing 类型<br>在 Kotlin 中，有些函数的“返回值类型”的概念没有任何意义，此时 Kotlin 使用一种特殊<br>的返回值类型 Nothing 来表示，Nothing 是一个空类型，也就是说在程序运行时不会出任何一<br>个 Nothing 类型的对象。在程序中，可以使用 Nothing 类型来标记一个永远不会有返回数据<br>的函数，具体示例代码如下：<br>fun fail(message: String): Nothing {<br>throw IllegalArgumentException(message)<br>}<br>当调用含有 Nothing 类型的函数时，可能会遇到这个类型的一种情况就是类型推断，这个<br>类型的可空类型为 Nothing?，该类型有一个可能的值是 null，如果用 null 来初始化一个变量的<br>值，并且又不能确定该变量的具体类型时，编译器会推断这个变量的类型为 Nothing?类型，具<br>体示例代码如下：<br>val x = null //变量“x”的类型为“Nothing?”<br>val l = listOf(null) //变量“l”的类型为“List&lt;Nothing?&gt;”<br>上述代码中，变量 x 的初始值为 null，并且该变量的具体类型不确定，因此编译器会推断该<br>变量的类型为“Nothing?”。 变量 l 的初始值为 listOf(null)， 可以看到 List 集合的初始值为<br>null，此时不能确定该集合的具体类型，因此编译器会推断该集合的类型为“List&lt;Nothing?&gt;”。<br>Unit 与 Nothing 之间的区别是：<br> Unit 是一个真正的类，继承自 Any 类，只有一个值，也就是所谓的“单例”（目的在<br>于函数返回 Unit 时避免分配内存），可省略。<br> Nothing：表示永远都不会有返回，所以，Nothing 是没有实例的，程序运行时不会出<br>现任何一个 Nothing 类型对象，在抛出异常的函数中，返回的类型设置为 Nothing。<br> Nothing? ：它唯一允许的值是 null ，被用作任何可空类型的空引用。12.5. 受检异常<br>Java 中有两种异常类型，一种是受检异常，一种是非受检异常，在编写 Java 代码时，由于<br>编译器在编译时会检查受检异常，因此 IDEA 会提示进行 try…catch 操作。<br>而 Kotlin 中相比于 Java 没有了受检异常，IDEA 也不会提示进行 try…catch 操作。</p>
<h1 id="13-泛型"><a href="#13-泛型" class="headerlink" title="13. 泛型"></a>13. 泛型</h1><p>13.1. 概述<br>在实现集合类时，如果不使用泛型，那使用的是 Object[]数组，但是这种实现方式存在如下<br>的问题：<br> 向集合中添加对象元素的时候，没有对元素的类型进行检查。也就是说，我们向集合中添<br>加任意对象，编译器都不会报错。<br> 从集合中获取一个值的时候，不能都使用 Object 类型，需要进行强制类型转换。而这个<br>转换过程由于在添加元素的时候没有做任何的类型的限制与检查，所以容易出错。<br>所以，提出在设计类的时候，给定一个虚拟类型，在实例化的时候，所有的对象都必须是此<br>类型（C++类模板，Java 的泛型）。<br>13.2. 在类、接口和函数上使用泛型</p>
<p>1) 泛型类/接口<br>使用泛型标记的类称为泛型类。当定义泛型时，泛型是在类型名之后、主构造函数之前用尖<br>括号“&lt;&gt;”括起来的类型参数。<br>class/interface 类/接口名&lt;E,K,…&gt;(){ … } //注意，泛型参数可以有多个<br>E,K 为类型参数，表示某种类型（名称自定），定义时是一个未知类型，当创建类的实例时，<br>需要传入具体的类型。例如：<br>class Box<T>(t: T) { //构造函数参数 t 的类型为 T<br>var value = t<br>}<br>val box: Box<Int> = Box<Int>(1) //创建实例，传入具体类型为 Int<br>当定义泛型类型的实例时（注意，不是在定义类时），可以完整地写明类型参数，如果编译器<br>可以自动推断类型参数，则可以省略类型参数。例如：<br>val box = Box(1) //编译器可以自动推断出参数 1 是 Int 类型，所以省略类型参数<br>由于传递到构造函数中的参数是 1，这个参数是一个 Int 类型的参数，编译器可以推断出泛<br>型的类型是 Int 类型，因此在创建类的实例时可以省略类型参数。<br>2) 自定义泛型函数<br>也可以直接在类或接口中的函数声明泛型参数或者在包级函数中直接声明泛型参数，格式：<br>可见性修饰符 fun &lt;泛型符号&gt; 函数名(参数): 函数返回值{<br>… }<br>例如：<br>class MyClass{<br>fun <T> show(t:T){ … }<br>}<br>13.3. 泛型约束/泛型上届</p>
<p>1) &lt;T : 类或接口&gt;约束<br>泛型约束是对类或者方法中的类型参数进行约束。例如：当创建一个泛型 List<E>时，类型<br>参数 E 理论上是可以被替换为任意的引用类型，但是有时候需要约束泛型实参的类型，例如想对<br>E 类型变量求和，则 E 应该是 Int 类型、Long 类型、Double 类型或者 Float 类型等，而不应<br>该是 String 类型，因此在特殊情况下，需要对类型变量 E 进行限制。<br>格式：<br>&lt;T : 类或接口&gt;<br>泛型约束也称之为泛型的上界，表示在实例化类型参数时，类型 T 必须是后面的类/接口或其<br>子类。并且，如果泛型约束中指定了类型参数的上界，则可以调用定义在上界类中的方法。<br>fun <T : Number> twice(value: T): Double {<br>return value.toDouble() * 2<br>}<br>fun main(args: Array<String>) {<br>println(“4.0 的两倍：${twice(4.0f)}”) //将 4.0f 传递到 twice()中并打印结果<br>println(“4 的两倍：${twice(4)}”) //将 4 传递到 twice()中并打印结果<br>}<br>运行结果：<br>4.0 的两倍：8.0<br>4 的两倍：8.0<br>在上述代码的 twice()方法中，参数 value 调用的 toDouble()方法是在 Number 类中定义<br>的。由于在泛型约束<T : Number>中已经指定类型参数的上界为 Number，因此 twice()方法中<br>传递的参数 value 可以调用定义在上界类 Number 中的方法（虽然参数为 Float 和 Int 类型）。<br>如果上界约束需要多个约束，则可以通过 where 语句来完成。例如：<br>fun <T> manyConstraints(value: T) where T : CharSequence, T : Appendable{ … }<br>通过 where 关键字实现了上界约束的多个约束，每个约束中间用逗号分隔，并且传递的参<br>数 value 可以调用第 1 个约束类中的方法，同时也可以调用第 2 个约束类中的方法。<br>2) &lt;T : Any?&gt;与<T : Any>约束<br>默认的上届是&lt;T : Any?&gt;，&lt;T : Any?&gt;表示类型实参是 Any 的子类，且类型实参可以为 null。<br><T : Any>表示类型实参是 Any 的子类，且类型实参不可以为 null。在 Kotlin 中，Any 类型是任意类型的父类型，类似 Java 中的 Object 类，因此声明的&lt;T : Any？&gt;等同于<T><br>13.4. 协变与逆变(out/in)</p>
<p>1) 协变(out)<br> 协变：若泛型的类型参数存在继承关系，那使用泛型时可以进行向上转换性质的转换（注<br>意，类型本身之间不存在继承关系）。例如：如果 Ch 是 Pa 的子类型，协变就是 Generic<Ch><br>也是 Generic<Pa> 的子类型。协变语法上用 out 表示。<br>例如程序如下：<br>class Test<T> //定义一个泛型类<br>fun main() {<br> var ta:Test<Any>?=null //定义类型参数为 Any 的泛型类变量 ta<br> var tb:Test<String>?=null //定义类型参数为 String 的泛型类变量 tb<br> ta=tb //错误，提示：推断的类型是 Test<String>?，但是需要的类型是 Test<Any>?<br>}<br>从上面的例题可以看到，虽然 ta 和 tb 都是 Test 类，但是不能互相赋值。也就是说，泛型类<br>定义对象时，类型参数不一样，定义的变量类型也是不一样的。<br>假设不是这样的设定，不管泛型类中的类型参数差别有多大，定义的变量都看做同一个类型，<br>那实际运用时，错误将非常多。例如 List<E>类型，可以放入简单的 Int，也可以放入复杂的对象，<br>那 List 对象之间的差异非常明显，这些实例如果是同一个类型，那运用相同的方法时，肯定会产<br>生错误。<br>协变考虑的是定义的泛型变量的类型参数之间存在继承关系的情况，例如：<br>class Test<out T> //定义支持协变的泛型类<br>fun main() {<br> var ta:Test<Any>?=null<br> var tb:Test<String>?=null<br> ta=tb //可以，因为类型参数 String 是 Any 的子类，所以 tb 向上转型<br>}<br>特点：<br> out 关键字只能出现在泛型类/接口的泛型参数声明上，表示支持协变，不能出现在泛型<br>方法的泛型参数声明上。所以’out’修饰的泛型常常作为方法的返回而使用。<br>例如：<br>interface Product<out T> {<br>fun produce(): T<br>fun add(t: T) //编译器报错<br>}<br> out 的另一层意思是只能输出，不能输入，与向上转型类似，基类不能操作子类中特有的元素，所以约定为只读。<br>例如：<br>//定义父类<br>open class Animal(val name: String) {<br> open fun sound() { println(“我是动物$name”) }<br>}<br>//定义子类<br>class Dog(name: String) : Animal(name) {<br> override fun sound() { println(“我是狗${name}，汪汪汪”) }<br>}<br>//定义函数，参数类型为 List<Animal>，表示此泛型支持协变<br>fun setAnimal(animalList: List<out Animal>) {<br> for (item in animalList) { //调用 List 中每个对象的 sound 方法<br> item.sound()<br> }<br>}<br>fun main() {<br>//创建 animalList1 对象，泛型参数为 Animal<br> val animalList1: MutableList<Animal> = ArrayList()<br> animalList1.add(Animal(“ani”))<br>//创建 animalList2 对象，泛型参数为 Dog<br> val animalList2: MutableList<Dog> = ArrayList()<br> animalList2.add(Dog(“dog22”))<br>// MutableList<Animal>和 MutableList<Dog>没有继承关系，都是 List 对象，但是<br>他们的泛型存在继承关系。且函数 fun setAnimal(animalList: List<out Animal>) 的<br>参 数 类 型 为 支 持 协 变 的 泛 型 ， 所 以 ， 可 以 将 MutableList<Dog> 作 为<br>MutableList<Animal>的子类来用。<br> setAnimal(animalList1)<br> setAnimal(animalList2)<br>}<br>注意：kotlin 中，List 默认实支持协变的泛型。所以即使将 out 拿掉，程序也可以正常运行。<br>2) 逆变(in)<br> 逆变：与协变情况类似，在实例化的对象之间存在类型向下转换，父类向子类转换（java<br>中不允许），用 in 表示。<br>特点<br> 泛型参数在使用了 in 关键字后，不能声明成 val 或者 rar 类型的变量。 用 in 关键字声明的泛型参数类型可以作为方法的参数类型，但是不能作为方法的返回值<br>类型。例如：<br>interface WritableList<in T> {<br>fun add(t: T): Int //允许<br>fun get(index: Int): T //不允许，这句代码的写法是错误的。<br>}<br>同样用协变中的简单例题来说明其应用：<br>class Test<in T> //声明支持逆变的泛型<br>fun main() {<br>var ta:Test<Any>?=null<br>var tb:Test<String>?=null<br>tb=ta //泛型参数类型为父类的对象赋值给子类对象<br>}</p>
<h1 id="14-集合"><a href="#14-集合" class="headerlink" title="14. 集合"></a>14. 集合</h1><p>14.1. 概述<br>kotlin 的集合类就是一个容器，用于存储一系列对象，这些对象可以是任意的数据类型，并<br>且长度可变。集合类都在 kotlin.collections 包内。<br>kotlin 中的集合按照其存储结构可以分为两大类，即单列集合（Collection）和双列（Map）<br>集合。</p>
<p>1) Collection<br>Collection 接口有 3 个常用子接口，分别是：List（有序可重复）、Set（无序不重复）和<br>MutableCollection（元素可变），MutalbleCollection 一般被 List 实现类和 Set 的实现类实现，<br>用于可变集合。<br>一般将实现 List 接口的对象称为 List 集合。在 List 集合中允许出现重复的元素， 所有的元<br>素是以一种线性方式存储的，在程序中可以通过索引来访问集合中的指定元素。<br>List 接口在 Kotlin 中有两个实现类，分别为 ArrayList（不可变）、MutableList（可变）。<br>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合（List、Set、<br>MutableCollection）通用的一些方法，这些方法可用于操作所有的单列集合，如下表所示：<br>方法 功能<br>add(element:E):Boolean 向集合中添加一个元素<br>addAll(element:Collection<E>) 将指定 Collection 中的所有元素添加到该集合中<br>clear():Unit 删除该集合中的所有元素<br>remove(element:E):Boolean 删除集合中指定的元素<br>removeAll(element:Collection<E>) 删除该集合中的所有元素<br>isEmpty(): Boolean 判断该集合是否为空属性：val size: Int 获取该集合中元素个数<br>… …<br>2) Map<br>Map 是双列集合的根接口，用于存储具有键（Key）、值（Value）映射关系的元素，每个元<br>素都包含一对键值，在使用 Map 对象时，可以通过指定的 Key 找到对应的 Value。其类的继承关<br>系如下：<br>3) 可变与不可变集合<br>根据可变性，集合分为可变集合和不可变集合。可变集合可以对集合中的元素进行增加、删<br>除的操作（mutableList）。不可变集合只提供只读操作（ArrayList）。<br>注意：val 定义的集合类型，只是不能改变其引用，若是可变集合，本身是可以改变的，例如<br>val 定义的可变集合，通过 add()函数添加元素是可以的。<br>注意：只读集合是协变的，可变集合不是。<br>14.2. 创建集合对象<br>可以使用 listOf()、setOf()、mapOf()函数创建不可变的 List 列表容器、Set 集容器、Map<br>映射容器；<br>可 以 使 用 mutableListOf() 、 mutableSetOf() 、 mutableMapOf() 函数来创建可变的<br>MutableList 列表容器、MutableSet 集容器、MutableMap 映射容器；<br>如下图所示：<br>Map<br>HashMap<br>LinkedHashMap<br>MutableMap例如：<br>//创建不可变 List<br>val list = ListOf(1,2,3,4,5,6) // val list: List<Int>=ListOf()，由于可以推导出类型，所以<br>可省略类型，下面的原理都是一样的<br>//创建可变 MutableList<br>val mutableList=mutableListOf(“a”,”b”,”c”)<br>//创建不可变 Set<br>val set = setOf(1,2,3,4,5,6)<br>//创建可变 MutableSet<br>val mutableSet = mutableSetOf(“a”,”b”,”c”)<br>//创建不可变 Map<br>val map = mapOf(1 to “a”, 2 to “b”)<br>//创建可变 MutableMap<br>val mutableMap = mutableMapOf( 1 to “a”, 2 to “b” )<br>注意，to 符号创建了一个短时存活的 Pair 对象，因此建议仅在性能不重要时才使用它。为避<br>免过多的内存使用，请使用其他方法。例如，可以创建可写Map 并使用写入操作填充它。apply()<br>函数可以帮助保持初始化流畅。<br>val map=mutableMapOf&lt;String,String&gt;().apply{ this[“one”]=”1”;this[“two”]=”2” }<br>如果创建没有元素的空 List，使用 listOf()即可。不过变量的类型不能省略，需要显式声明，<br>否则会报错。<br>val emptyList:List<Int>=listOf() //显式声明 List 的元素为 Int<br>具体类型构造函数<br>要创建具体类型的集合，例如 ArrayList 或 LinkedList，可以使用这些类型的构造函数。<br>类似的构造函数对于 Set 与 Map 的各实现中均有提供。<br>例如：<br>val linkedList = LinkedList<String>(listOf(“one”,”two”, “three”))<br>val presizedSet = HashSet<Int>(32)<br>复制：<br>标准库中提供的 toList()、toMutableList() 、toSet()等创建了一个具有相同元素的新集合14.3. 遍历集合中的元素<br>List、Set 和 Map 类继承了 Iterable 接口，扩展了 forEach 函数来迭代遍历元素； 例如：<br>list.forEach{ … }<br>set.forEach{ … }<br>map.forEach{ … }<br>若要访问 index 下标，在 List 和 Map 对象中，可以使用 forEachIndex 函数，例如：<br>list.forEachIndex{ index,value-&gt;<br>println(“${index} , ${value}”)<br>}<br>第一个参数 index 是下标，第二个参数 value 是对应下标位置上的值。<br>Map 的元素是 Entry 类型，与 List 和 Set 不同，Map 没有下标，只有 key 和 value，由 entries<br>属性持有。<br>val entries: Set&lt;Entry&lt;K, V&gt;&gt;<br>这个 Entry 类型定义如下：<br>public interface Entry&lt;out K, out V&gt; {<br>public val key: K //键值对的 Key<br>public val value: V //键值对的 Value<br>}<br>可以直接访问 entries 属性获取该 Map 中的所有键／值对的 Set。<br>代码如下：<br>val map = mapOf(1 to “a”, 2 to “b”)<br>map.entries.forEach( print( it.key+it.value ) )<br>14.4. 查询和检索<br>操作主要有判断集合是否为空、集合中元素个数、返回集合中的元素迭代器、查询某个位置<br>的元素等，常用的方法有：<br>对象 查询方法 功能<br>List/Set/Map isEmpty():Boolean 集合是否为空<br>List/Set/Map val size:Int 集合中元素个数<br>List/Set/Map contains() 判断结合是否包含某个元素<br>List/Set iterator():Iterator<E> 返回集合元素迭代器<br>List/Set get(index:Int):E 查询集合中某个位置的元素<br>List/Set add(element: E): Boolean 向集合中添加元素，成功返回 ture<br>List/Set add(index: Int, element: E):<br>Unit<br>在指定位置添加一个元素<br>List/Set remove(element: E): Boolean 移除集合中的元素，成功返回 tureList/Set removeAt(index: Int): E 移除指定索引处的元素<br>List/Set set(index: Int, element: E): E 用指定的元素替换集合中指定位置的元<br>素，返回该位置的原元素<br>Map get(key: K): V? 根据 key（键）获取 value（值），如果该<br>元素存在，则返回元素的值，否则返回 null<br>Map put(key: K, value: V): V? 将指定的 value 与映射中指定的 key 添加<br>到集合中<br>Map remove(key: K): V? 移除集合中指定的 Key 映射的元素<br>例如：<br>//List 对象的操作<br>val list: List<Int> = listOf(0, 1, 2)<br>if (list.isEmpty()) { //判断集合中元素是否为空<br>println(“集合中没有元素”)<br>return<br>} else {<br>println(“集合中有元素，元素个数为：” + list.size)<br>}<br>//Map 对象的操作<br>val muMap = mutableMapOf(1 to “江小白”, 2 to “小小白”, 3 to “江小小”)<br>muMap.put(4, “江江”)<br>println(“添加元素后的集合：” + muMap)<br>muMap.remove(4)<br>println(“删除元素后的集合：” + muMap)<br>println(“集合中元素的个数为：” + muMap.size)<br>}<br>14.5. 过滤函数<br>filter 函数，例如：<br>//创建 Student 类<br>data class Student(var id:Long, var name:String , var age:Int){<br>…<br>}<br>//创建 List 对象<br>val studentList = listOf(<br>Student(1,”jack”,18), Student(2,”beny”,18), Student(3,”rose”,19),<br>)//过滤出年龄大于等于 19 的学生<br>studengList.filter{ it.age&gt;=18 }<br>14.6. 排序函数<br>升序：sorted()<br>倒序：reversed()<br>例如：<br>list.sorted() / list.reversed()<br>set.sorted() / set.reversed()<br>14.7. 元素去重<br>distinct()函数，例如：<br>val dupList = listOf(1, 1, 2, 2, 3, 3, 3)<br>dupList.distinct() //去重函数，返回 [1, 2, 3]</p>
<h1 id="15-IO"><a href="#15-IO" class="headerlink" title="15. IO"></a>15. IO</h1><p>15.1. 概述<br>Kotlin 的 I/O 操作的 API 在 kotlin.io 包下。Kotlin 的原则就是 Java 已经有的好用的类就直<br>接使用，没有的或者不好用的类，就在原有类的基础上进行功能扩展。例如 Kotlin 就给 File 类写<br>了扩展函数。<br>Kotlin 为 java.io.File 类扩展了大量好用的扩展函数，这些扩展函数都在 kotlin\io\File<br>ReadWrite.kt 源代码文件中。<br>同时，Kotlin 也针对 InputStream、OutputStream 和 Reader 等都做了简单的扩展。它们<br>主要在 kotlin\io\IOStreams.kt、kotlin\io\ReadWrite.kt 源代码文件中。<br>Koltin 的序列化直接采用了 Java 序列化类的类型别名：<br>internal typealias Serializable = java.io.Serializable<br>Kotlin 中常用的文件读写 API 如下表所示：<br>函数 功能<br>File.readText(charset:Charset=Charset.UTF_8):<br>String<br>读取文件内容，返回一个字符串<br>File.readLines(charset:Charset=Charset.UTF<br>_8):List<br>读取文件每一行，存入一个 List 返回<br>File.readByte():ByteArray 文件内容以 ByteArray 返回<br>File.writeText(text:String,charset:Charset=Char<br>set.UTF _8):Unit<br>text 字符串覆盖写入到文件中<br>File.writeBytes(array:ByteArray):Unit ByteArray 字节流数组覆盖写到文件File.appendText(text:String,charset:Charset=C<br>harset.UTF _8):Unit<br>文件末尾追加写入 text 字符串<br>File. appendBytes(array:ByteArray):Unit 文件末尾追加写入 ByteArray 字节流<br>数组<br>File 类：<br>File 类专门用来管理磁盘文件和文件夹(增、删、改名)，而不负责数据的输入输出。每个 File<br>类对象表示一个磁盘文件或者文件夹。构建对象的方法为：<br>var file = File(pathname:String)<br>注意：在 Android 开发中，一般不会直接使用绝对路径。<br>15.2. 读文件<br>//通过 readText()函数读取一个文件，直接返回整个文件内容<br>fun getFileContent(filename:String):String{<br>val file=File(filename)<br>return file.readText( Charset.forName(“UTF-8”) ) //获取整个文件的内容，并返回<br>UTF-8 编码格式的字符串<br>}<br>接着使用 File 对象来调用 readText()函数即可获得该文件的全部内容，它返回一个字符串。<br>如果指定字符编码，可以通过传入参数 Charset 来指定，默认是 UTF-8 编码。<br>//通过 readLines()函数获取文件每行的内容<br>fun getFileLines(filename:String):List<String>{ //返回每一行构成一个 String 元素的 List<br>val file=File(filename)<br>return file.readLines( Charset.forName(“UTF-8”) )<br>}<br>//通过 readBytes()函数读取字节流数组<br>//读取为 bytes 数组<br>val bytes: ByteArray = file.readBytes() //返回这个文件的字节数组<br>15.3. 写文件<br>写文件通常分为覆盖（一次性写入）和追加两种情况。</p>
<ol>
<li>writeText：覆盖写文件<br>fun writeFile(text: String, destFile: String) {<br>val f = File(destFile) //destFile 参数是目标文件名（带目录）。<br>if (!f.exists()) {<br>f.createNewFile()<br>}<br>f.writeText(text, Charset.defaultCharset()) //覆盖写入字符}</li>
<li>appendFile：末尾追加写文件<br>fun appendFile(text: String, destFile: String) {<br>val f = File(destFile)<br>if (!f.exists()) {<br>f.createNewFile()<br>}<br>f.appendText(text, Charset.defaultCharset()) //追加写入内容<br>}</li>
<li>appendBytes：追加写入字节数组<br>追加字节数组到该文件中方法签名：<br>fun File.appendBytes(array: ByteArray)</li>
<li><ol start="4">
<li>遍历文件树</li>
</ol>
</li>
<li>walk 函数：遍历文件树<br>fun traverseFileTree(filename: String) {<br>val f = File(filename)<br>val fileTreeWalk = f.walk()<br>fileTreeWalk.iterator().forEach { println(it.absolutePath) }<br>//遍历指定文件夹下<br>}<br>上面的测试代码将输出当前目录下的所有子目录及其文件。我们还<br>可以遍历当前文件下所有的子目录文件，将其存入一个 Iterator 中：<br>fun getFileIterator(filename: String): Iterator<File> {<br>val f = File(filename)<br>val fileTreeWalk = f.walk()<br>return fileTreeWalk.iterator()<br>}</li>
</ol>
<h1 id="16-线程"><a href="#16-线程" class="headerlink" title="16. 线程"></a>16. 线程</h1><p>16.1. 同步和异步<br>例如：烧开水需要 15 分钟，洗碗需要 5 分钟，扫地需要 5 分钟，请问做完这三件事，总共<br>需要几分钟？<br>同步就是做完一件事情后才能进行下一件事。异步就是同时进行一个以上彼此目的不同的任<br>务，例如在烧水的时候，可以同时扫地和洗碗的工作。16.2. 回调<br>既然有了异步，那是不是所有的事情都可以通过异步去完成呢？考虑到一种情况，洗碗需要<br>热水，这时候就需要等烧水这个事情做完才可以洗碗了，也就是洗碗依赖于烧水什么时候执行完。<br>这个情况异步需要如何处理呢？<br>如果我们在水壶上安装一个汽笛，在水烧开时可以发出鸣叫。这样，在烧水的过程中伦然可<br>以去做其他的工作，这个汽笛就是异步中的回调机制。<br>这样的概念在程序设计中使用非常频繁，例如：<br>Android 中，渲染某个视图依赖于网络请求这个耗时操作的结果才能进行，所以主线程在发<br>起网络请求的时候，为网络请求配置了回调，以便在网络请求完成的时候，回调函数被调用，主<br>线程就可以继续用网络请求的结果渲染某个视图了，而等待网络请求结果的时候，主线程可以做<br>其他的事情。<br>所以，需要回调机制的原因就很明显了，就是因为不同的任务之间存在前后的依赖关系。<br>但是，函数回调也有缺陷，那就是代码结构过于耦合，遇到多重函数回调的嵌套，代码难以<br>维护。<br>16.3. java 的多线程<br>Java 的线程是通过 java.lang.Thread 类来实现的。<br>public class Thread implements Runnable //注意：Thread 类实现了 Runnable 接口，<br>所以 Thread 类也是 Runnable 的实现类<br>Java 的线程类是 java.lang.Thread 类。当生成一个 Thread 类的对象之后，一个新的线程就<br>被创建了（创建状态）。Java 中线程任务都是通过 Thread 对象的方法 run()来完成其操作的，方<br>法 run( )称为线程体，注意：线程必须要通过 Thread 对象的 start()方法才能启动。<br>下面是构建线程对象几种常用的方法：<br> public Thread() public Thread(String name)<br> public Thread(Runnable target) //Thread 类实现了 Runnable 接口，所以 Runnable<br>的实现类对象可以作为参数来构建 Thread 对象<br> public Thread(Runnable target, String name)<br>参数 target 是一个实现 Runnable 接口的实例，它的作用是实现线程体的 run()方法。目标<br>target 可为 null，表示由 Thread 本身实例来执行线程。name 参数指定线程名字，但没有指定<br>的构造方法，线程的名字是 JVM 分配的，例如 JVM 指定为 thread-1、thread-2 等名字。<br>Java 线程对象生成的两种方法：</p>
<p>1) 生成一个 Thread 类的子类，并在子类中重写其 run 方法（构造函数 1、2）。<br>2) 生成一个 Runnable 接口实现类的对象（构造函数 3、4），用此对象来实例化 Thread 对<br>象<br>16.4. kotlin 中的线程<br>在 kotlin 中，创建线程的方式与 java 中类似，分别如下：</p>
<p>1) 继承 Thread 类<br>object : Thread() {<br>override fun run() {<br>println(“running from Thread: ${Thread.currentThread()}”)<br>}<br>}.start()<br>2) 使用 Runnable 类的实例初始化 Thread 对象<br>Thread{ //lambda 表达式代替 Runnable 对象<br> println(“running from lambda: ${Thread.currentThread()}”)<br>}.start()<br>这里并没有看到 Runnable 对象，其实是被 lambda 表达式代替了。因为 lambda 可以传<br>给任何期望函数式接口的方法，而在此处，编译器会自动把它转换成一个 Runnable 实例。效<br>果等同于：<br>object :Runnable{<br>override fun run() {<br>println(“running from lambda: ${Thread.currentThread()}”)<br>}<br>}<br>顺序代码结构是阻塞式的，每一行代码的执行都会使线程阻塞在那里，但是主线程的阻塞<br>会导致很严重的问题, 这就要求所有的耗时操作不能在主线程中执行，所以就需要多线程来执<br>行。<br>通常线程切换的工作是由异步函数内部完成的，即通过回调的方式异步调用外界注入的代码。也就是说，异步回调其实就是代码的多线程顺序执行。<br>那么能不能既按照顺序的方式编写代码，又可以让代码在不同的线程顺序执行呢？有没有<br>帮助我们自动地完成线程的切换工作的功能呢？这个就是 Kotlin 协程的作用了。</p>
<h1 id="17-协程（Coroutine）"><a href="#17-协程（Coroutine）" class="headerlink" title="17. 协程（Coroutine）"></a>17. 协程（Coroutine）</h1><p>添加依赖（注意版本变化）：<br>implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9’<br>implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9’<br>上一个是 java 环境下的，下面一个是 android 环境下的。<br>或者通过可视化方式添加<br>17.1. kotlin 的协程<br>第一个例子<br>假设需要用 30 分钟进行煮饭，打电话给请朋友吃饭，朋友需要 50 分钟才能到你家。那么，<br>是不是你需要消耗 30 + 50 = 80 分钟？<br>实际上，在现实中只需要消耗 50 分钟就可以了，先给朋友打电话，让他现在出门，把米淘洗<br>干净，放进电饭煲并打开电源，然后要做的就是等待。<br>第二个例子<br>假设需要完成语文试卷，数学试卷和英语试卷。每张试卷需要做 1 小时。于是需要 1 + 1 + 1<br>= 3 小时来完成所有的试卷。<br>能异步与不能异步<br>在第一个例子里面，煮饭、等朋友有一个共同点，就是每个操作看似耗时很长，但真正需要<br>人去操作的只有很少的时间，剩下的大部分时间都不需要人来操作，都是等待即可。<br>再看第二个例子，每一张试卷都会占用整个你，没有等待的时间，所以必须一张一张试卷完<br>成。<br>这两个例子实际上对应了两种程序类型：I/O 密集型程序和计算密集型程序。<br>在使用 requests 请求 URL、查询远程数据库或者读写本地文件的时候，就是 I/O 操作。这<br>些操作的共同特点就是要等待。大量的时间浪费在等待网站返回数据。如果可以充分利用这个等<br>待时间，就能发起更多的请求。而这就是异步请求为什么有用的原因。<br>但对于需要大量计算任务的代码来说，CPU 始终处于高速运转的状态，没有等待，所以就不<br>存在利用等待时间做其它事情的说法。<br>所以：异步只适用于 I/O 操作相关的代码，不适用于非 I/O 操作。<br>线程会因为 Thread.sleep 方法而进入阻塞状态（就是什么也不会执行），这样就浪费资源了。<br>能不能将代码块打包成一个个可执行片段，由一个统一的分配器去分配到线程上去执行呢？例如<br>某个代码块里要求 sleep 一会，那么就去执行别的代码块，等会再来执行。<br>协程就是这样一个东西，作为使用者不需要再去考虑创建一个新线程去执行一段代码，也不<br>需要关心线程怎么管理，只需要关心要异步执行一段代码，且要拿到执行的结果，若要异步执行很多段代码，则要按某种顺序或者某种逻辑得到它们的结果。<br>所以，协程（Coroutine）是一个并发的设计模式，能通过它使用更简洁的代码来解决异步问<br>题。协程的内部也使用到了线程（对线程进行了更为方便的封装），但它更大的作用是它的设计思<br>想，协程去除了传统的 Callback 回调方式，将异步编程趋近于同步对齐。我们只需通过协程即可<br>完成线程切换等问题，非常方便。<br>协程主要有以下两个特点。<br>• 协程挂起：表示协程中执行的任务从协程所在的线程剥离，转到协程所指定的线程去执行<br>其任务，而当前线程继续执行自己的任务（就像在当前线程外挂了一个协程），这个剥离就叫做挂<br>起。协程挂起之后，原先所在的线程继续执行自己的任务，不会受到任何影响，所以称为非阻塞<br>挂起。注意：协程中“挂起”的对象不是线程，也不是函数，挂起的对象是协程。<br>• 简化代码：协程让原来使用“异步+回调”方式写出来的复杂代码，简化成可以用看似同<br>步的方式表达。<br>启动一个简单的协程：<br>GlobalScope.launch{<br>delay(1000L)<br>println(“Hello,World!”)<br>}<br>上述代码使用 GlobalScope.launch 方法启动了一个协程，GlobalScope 为协程作用域接口<br>的实现类，launch 后面的花括号就是协程，花括号内的代码就是运行在协程内的代码。<br>17.2. 挂起函数<br>suspend 修饰的函数称为挂起函数。注意：挂起函数只能在协程或者其他挂起函数中被调用，<br>即挂起函数必须直接或者间接地在协程中执行。<br>一个协程内有多个 suspend 修饰的方法顺序书写时，执行的顺序按照方法的排列顺序。若有<br>协程挂起时，线程不会空闲，而是继续往下运行，而前面挂起的那个协程在挂起结束后不会马上<br>运行，而是等待当前正在运行的协程运行完毕后再去执行。<br>所以说，协程的挂起可以理解为协程中的代码离开协程所在线程的过程，协程的恢复可以理<br>解为协程中的代码重新进入协程所在线程的过程。协程就是通过的这个挂起恢复机制进行线程的<br>切换。<br>普通函数的类型是()-&gt; Unit，但是加了 suspend 后，函数的类型为：suspend()-&gt; Unit。常<br>用的 delay、withcontext 等函数就是内置的挂起函数。<br>例如：<br>fun main(args:Array<String>){<br>println(“Start ${Thread.currentThread().name}”) //输出启动时的线程名<br>CoroutineScope(Dispatchers.Default).launch{ //主线程中，启动一个协程<br>delay(100) //挂起函数，协程挂起，但不影响线程运行println(“current ${Thread.currentThread().name}”) //等待延迟后执行<br>}<br>println(“End ${Thread.currentThread().name}”) //回到主线程，输出线程名<br>Thread.sleep(500) //保证 main 线程存活，确保上面两个协程运行完成<br>}<br>上述代码中通过 GlobalScope.launch 启动了一个协程，程序运行的结果如下：<br>从上面的例题可以看到，协程代码中，主线程并没有被阻塞，在挂起后，输出发生在主线程<br>中，说明协程的代码切换到其他线程之后，又自动切回了主线程，而这正是我们所需要的效果。<br>这就是“既按照顺序的方式编写代码，又可以让代码在不同的线程顺序执行”的“顺序编写异步<br>代码的效果”。顺序编写保证了逻辑上的直观性，协程的自动线程切换又保证了代码的非阻塞性。<br>如何做到挂起的<br>如果仅仅在函数前面加一个 suspend，那函数就能被挂起吗?<br>答案当然是不能的，所以 supend 关键字并不起到协程挂起/切换线程的作用。对于自定义挂<br>起函数，需要在该函数内部直接/间接调用到某一个自带的挂起函数才行，例如 withContext()、<br>delay()等。<br>具体的例题分析见下面的“协程切换”小节。<br>17.3. CoroutineScope 协程作用域</p>
<p>1) 概述<br>在 Android 环境中，通常每个界面（Activity、Fragment 等）启动的协程只在该界面有意<br>义，如果用户在等待 Coroutine 执行的时候退出了该界面，则不需要再继续执行此 Coroutine 了。<br>所以 Coroutine 在设计的时候，要求在一个范围内执行。例如，在 Android 中使用协程来请求<br>数据，当接口还没有请求完成时 Activity 就已经退出了，这时如果不停止正在运行的协程将会造<br>成不可预期的后果。所以要使用 Coroutine 须先确定一个协程的作用域（好比变量的作用域），<br>然后根据此来确定运行的协程。<br>CoroutineScope（协程作用域）用于管理协程，管理的内容有：<br> 启动协程的方式：它定义了 launch、async、withContext 等协程启动方法(以 extention<br>的方式)，并在这些方法内定义了启动子协程时上下文的继承方式。<br> 管理协程生命周期 - 它定义了 cancel()方法，用于取消当前作用域，同时取消作用域内<br>所有协程。<br>CoroutineScope 是一个接口，定义为：<br>public interface CoroutineScope {<br> //协程运行环境(上下文，包含如 dispatcher 等对象) public val coroutineContext: CoroutineContext<br>}<br>coroutineContext：<br>可以看到，CoroutineScope 接口中仅定义了一个 CoroutineContext 属性，即协程的运行<br>环境，它包含一个协程运行所需的各种参数，包括协程调度器（dispatcher）、代表协程本身的 Job<br>（任务管理器）、协程名称、协程 ID 等。CoroutineContext 定义为一个带索引的集合，集合的元<br>素为 Element，上面所提到调度器、Job 等都实现了 Eelement 接口。<br>由于 CoroutineContext 被定义为集合，因此在实际使用时可以自由组合加减各种上下文元<br>素。例如：CoroutineScope(Dispatchers.Main)，参数调度器表示的就是一个元素，由此元素构<br>成 CoroutineContext 对象。<br>CoroutineScope 是提供 CoroutineContext 的容器，保证 CoroutineContext 能在整个协<br>程运行中传递下去，约束 CoroutineContext 的作用边界。所以，作用域用于管理协程；而上下<br>文只是一个记录协程运行环境的集合。<br>所以，GlobalScope.launch{ }代码中的 GlobalScope 实现了 CoroutineScope 接口，launch()<br>是 CoroutineScope 的一个扩展函数，功能是启动一个协程，在 CoroutineScope 上还有很多<br>扩展函数，比如：async、actor、cancel 等。<br>2) CoroutineScope<br> GlobalScope<br>GlobalScope 它是 CoroutineScope 的一个单例对象，表示此协程的生命周期伴随应用程序<br>的生命周期，在该作用域启动的协程为顶层协程。<br>普通协程会受到外层的一个作用域的生命周期的影响，而 GlobalScope 所创建的协程为顶层<br>协程，没有外部作用域，所以不受外层的影响。且该 CoroutineScope 没有 Job 对象(管理任务器)，<br>就无法对它执行 cancel()操作，如果不手动取消每个任务，会造成这些任务一直运行，可能会导<br>致内存泄露等问题。<br>所以 Android 中一般而言不直接使用 GlobalScope 来创建 Coroutine。<br> CoroutineScope( Dispatchers.xxx )方法<br>此方法为内置的工厂方法（不是构造函数）。Dispatchers 为调度器，其作用是指定协程运行<br>在某一特定线程、线程池中或不指定（自动选择）运行的线程。<br>协程调度器 有 ： Dispatchers.Default 、 Dispatchers.IO 、 Dispatchers.Main 和<br>Dispatchers.Unconfined。<br> Dispatchers.Default：默认线程池，核心线程和最大线程数依赖 cpu 数量，适合 CPU<br>密集型的任务，比如解析 JSON 文件，排序较大的 list。<br> Disspatchers.IO：工作线程池，针对磁盘和网络 IO 进行了优化，适合 IO 密集型的<br>任务，比如：读写文件，操作数据库以及网络请求。<br> Dispatchers.Main：主线程，在主线程中操作 UI，防止 UI 阻塞，如果没有 UI 的话<br>一般没有必要使用。 Dispatchers.Unconfined：非受限调度器，会根据运行时的上线文环境决定。<br>例如：CoroutineScope(Dispatchers.Main)，就是指定该 CoroutineScope 启动的协程在主<br>线程执行。<br>17.4. 启动协程<br>在 Kotlin 程序中，启动一个协程的方式有很多种，常见的如下所示：<br> CoroutineScope.launch():Job 函数：异步启动一个不会阻塞当前线程的 Coroutine，返<br>回一个 Job 对象（不需要 return 语句）用于控制这个 Coroutine。注意，函数必须通过<br>CoroutineScope 实 例 才能调用 ， 创 建 方 法 如 上 一 小 节 所 述 ， 如 ：<br>CoroutineScope( Dispatchers.xxx )。<br> CoroutineScope.async:Deferred：async 用于启动一个异步的协程任务，默认返回一个<br>Deferred（延迟）对象（不需要 return 语句），Deferred.await()用于得到协程任务结束<br>时返回的结果（最后一行的值）。同样的，函数必须通过 CoroutineScope 实例才能调用。<br> runBlocking:T 函数：创建一个 会 阻 塞 当 前 线 程 的 Coroutine ， 此方法 不 是<br>CoroutineScope 的扩展方法，可以独立使用。runBlocking 域中可以有多个协程，多个<br>协程可以并发进行，不会等待子协程执行结束通常只用于启动最外层的协程，例如线程环<br>境切换到协程环境。<br>注意，launch、async 有默认返回值，所以不能使用 return。</p>
<ol>
<li>CoroutineScope.launch()函数创建协程<br>最常用的方式是通过 launch()函数来启动协程。launch()函数如下：<br>public fun CoroutineScope.launch(<br>context: CoroutineContext = EmptyCoroutineContext,<br>start: CoroutineStart = CoroutineStart.DEFAULT,<br>block: suspend CoroutineScope.() -&gt; Unit ): Job<br>参数：<br> context: CoroutineContext ：协程的上下文，含当前 CoroutineScope 的信息，默认<br>值 EmptyCoroutineContext 表示一个空的协程上下文。<br> start: CoroutineStart ：CoroutineStart 枚举类型，用来指定 Coroutine 启动的选项。<br>有如下几个取值：<br> DEFAULT：（默认值）立刻安排执行该 Coroutine 实例<br> LAZY：延迟执行，只有当用到的时候才执行<br> ATOMIC：类似 DEFAULT，区别是当 Coroutine 还没有开始执行的时候无法取消<br> UNDISPATCHED：立刻在当前线程执行直到遇到第一个 suspension point 。然后<br>当 Coroutine 恢 复 的 时 候 ， 继 续 在 suspension 的 context 中设置的<br>CoroutineDispatcher 中执行。<br> block: suspend CoroutineScope.() -&gt; Unit ：一个 suspend 函数，这个就是协程中要执行的代码块， 注 意 ， 从 CoroutineScope.() 可以看到，此 block 函数定义为<br>CoroutineScope 的扩展函数，所以在代码块中可以直接访问 CoroutineScope 对象（即<br>this 对象）。在实际使用过程中通常使用 lambda 表达式，也称之为 Coroutine 代码块，<br>在此代码块中完成各种异步操作。<br>返回值：<br>函数返回一个 Job 类型（Job 为一个接口）的对象，Job 是协程任务的接口，里面定义了协<br>程的状态字段、cancel 方法、attach 方法等；该对象代表了这个刚刚创建的 Coroutine 实例。<br>基本上每启动一个协程就会产生对应的 Job。<br>Job 对象有 6 种不同的状态（New: 创建、Active: 运行、Completing: 已经完成等待自身<br>的子协程、Completed: 完成、Cancelling: 正在进行取消或者失败、Cancelled: 取消或失败）<br>这六种状态 Job 对外暴露了三种状态，可以通过 Job 对象获取：<br> val isActive: Boolean：运行状态<br> val isCompleted: Boolean：完成状态<br> val isCancelled: Boolean：取消状态<br>所以如果需要手动管理协程，可以通过下面的方式来判断当前协程是否在运行。<br>while (job.isActive) {<br>// 协程运行中<br>}<br>通过这个 job 对象可以控制这个 Coroutine 实例，比如：<br> job.start()：启动协程，除了 lazy 模式，协程都不需要手动启动<br> job.join()： 要求当前协程等待 job 执行完成之后再继续执行<br> job.cancel()：取消一个协程<br> job.cancelAndJoin()：等待 job 协程执行完毕然后再取消<br>一般来说，协程创建的时候就处在 Active 状态，但也有特例。例如通过 launch 启动协程的<br>时传递的 start 参数默认值是启动的，如果 start 传递的是 CoroutineStart.LAZY，那么它将处于<br>New 状态。可以通过调用 start 或者 join 来唤起协程进入 Active 状态。<br>例如：<br>val job = CoroutineScope(Dispatchers.Unconfined).launch{ //启动协程<br>var i = 1<br>while(true) {<br>println(“$i little sheep”) //开始数羊</li>
</ol>
<p>++i<br>delay(500L) //每半秒数一只, 一秒可以输两只<br>}<br>}<br>Thread.sleep(1000L) //在主线程睡眠期间, 协程里已经数了两只羊job.cancel() //协程才数了两只羊, 就被取消了<br>Thread.sleep(1000L)<br>2. async+await 函数创建协程<br>launch 方法的作用是建立协程并当即启动, 返回的是 Job 对象，但是 Job 为协程自身，用于<br>管理协程，却无法携带协程中处理的值。<br>async 和 await 是两个函数，它们一般一起使用，async 函数用于启动一个异步协程，并返<br>回 Deferred 对象，Deferred 是 Job 的子类，但 Deferred 有个 await 方法, 调用它可获得协程中<br>处理的值。<br>public fun <T> CoroutineScope.async(<br> context: CoroutineContext = EmptyCoroutineContext,<br> start: CoroutineStart = CoroutineStart.DEFAULT,<br>//launch 方法：block: suspend CoroutineScope.() -&gt; Unit ): Job<br> block: suspend CoroutineScope.() -&gt; T): Deferred<T><br>async 的特点是不会阻塞当前线程，但会阻塞所在协程。<br>注意: await 是 suspend 方法, 但 async 不是, 因此 async 能够在协程外面调用。 async 只<br>是启动了协程, 而不会引发协程挂起, 传给async的lambda(也就是协程体)才可能引发协程挂起。<br>例如：<br>fun main(…) {<br>CoroutineScope(Dispatchers.Unconfined).launch{<br>val deferred1 = async{ requestDataAsync() }<br>// await 方法为 suspend 方法，所以必须在协程中调用<br>println(“data=${deferred1.await()}”)<br>}<br>Thread.sleep(10000L)}<br>//创建挂起函数<br>suspend fun requestDataAsync(): String {<br>delay(1000L)<br>return “data1” //函数返回值<br>}<br>async 和 launch 的区别：<br> aunch 更多是用来发起一个无需结果的耗时异步任务，这个工作不需要返回结果。<br> async 函数则用于执行耗时并且需要返回值（如网络请求、数据库读写、文件读写）的异<br>步任务，在执行完毕通过 await() 函数获取处理值。17.5. 协程切换（withContext）<br>17.5.1.概述<br>在 suspend 函数执行完成之后，协程会自动把线程再切回来。那么是 suspend 关键字进行<br>的线程切换吗？怎么指定切换到哪个线程呢？对此可以做一个简单的试验：<br>GlobalScope.launch(Dispatchers.Main) {<br>println(“Hello ${Thread.currentThread().name}”)<br>test() //调用自定义的挂起函数<br>println(“End ${Thread.currentThread().name}”)<br>}<br>suspend fun test(){ //自定义一个挂起函数<br>println(“World ${Thread.currentThread().name}”)<br>}<br>执行结果为：Hello main -&gt; World main -&gt; End main，也就是说这个 suspend 函数仍然<br>运行在主线程中，suspend 并没有切换线程的作用。<br>可以通过 withContext 方法来在 suspend 函数中进行线程的切换，withContext 函数为：<br>suspend fun <T> withContext(<br>context: CoroutineContext,<br>block: suspend CoroutineScope.() -&gt; T<br>): T (source)<br>函 数 有 两 个 参 数 ， 参 数 1 的 取 值 可 以 是 Dispatchers.Default 、 Dispatchers.IO 、<br>Dispatchers.Main 和 Dispatchers.Unconfined。参数 2 可以是 lambda 函数，用于耗时操作。<br>例如：<br>GlobalScope.launch(Dispatchers.Main) {<br>println(“Hello ${Thread.currentThread().name}”)<br>val def = withContext(Dispatchers.IO){ //线程切换<br>println(“World ${Thread.currentThread().name}”)<br>val str = “my value”<br>}<br>println(“End ${Thread.currentThread().name}”)<br>println(def.await())<br>}<br>执行的结果为：Hello main  World DefaultDispatcher-worker-1  End mainmy<br>value，这说明 withContext 函数的确运行在不同的线程之中了，所以：<br> withContext 方法进行了线程切换的工作<br> withContext 是 suspend 函数，必须在协程中进行调用 函数最后一行语句的值为 Deferred.await()所获取的值<br>那么 suspend 关键字有什么用处呢？<br>其实，suspend 关键字只起到了标志这个函数是一个耗时操作，必须放在协程中执行的作用。<br>如果创建一个 suspend 函数，但是内部不包含正真的挂起逻辑，编译器会提醒： Redundant<br>‘suspend’ modifier ，即这个关键字是多余的。因为这个函数并不会发生挂起，那这个<br>suspend 只有一个效果：限制此函数只能在协程中被调用，如果在非协程中调用，则编译不会通<br>过。<br>所以，创建一个 suspend 函数，为了让他包含挂起，要在内部直接或者间接调用 Kotlin 自<br>带的 suspend 函数，这个时候函数才是有意义的，线程切换有多个方法，但是 withContext 是最<br>常用的一个。<br>所以，withContext（）函数可以指定线程来执行代码，并且执行完毕后再自动切换回来，继<br>续执行原先线程里的后续代码。<br>17.5.2.如何在主线程更新界面<br>针对界面的操作只能在主线程中进行，例如：<br>coroutineScope(Dispatchers.IO).launch{<br>val image = getImage(imageId)<br>coroutineScope(Dispatchers.Main).launch {<br>avatarIv.setImageBitmap(image)<br>}<br>}<br>好像有点不对劲？这不还是有嵌套嘛。<br>如果只是使用 launch 函数，协程并不能比线程做更多的事。不过协程中却有一个很实用的<br>函数：withContext 。这个函数可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动<br>把线程切回去继续执行。那么可以将上面的代码写成这样：<br>coroutineScope(Dispatchers.Main).launch { // 在 UI 线程开始<br>//切换到 IO 线程,执行完成后切回 UI 线程<br>val image = withContext(Dispatchers.IO) {<br>getImage(imageId) //运行在 IO 线程<br>}<br>avatarIv.setImageBitmap(image) //自动回到 UI 线程更新 UI<br>}<br>//或者：withContext 放进一个单独的函数，然后在 UI 线程中调用<br>launch(Dispatchers.Main) {<br> val image = getImage(imageId) //调用 withContext 函数<br> avatarIv.setImageBitmap(image)}<br>suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {<br> …<br>}<br>这就是“用同步的方式写异步的代码”。<br>17.6. 协程取消<br>比如 Android 中的网络请求等资源数据的加载，需要在页面关闭时中断<br>kotlin 协程的取消规则是这样的：<br> 父协程调用 cancel()，会取消自己以及所有子(内部)协程。<br> 子协程调用 cancel()，默认不会取消父协程。<br> 可以通过调用 CoroutineScope 的 cancel()方法，取消掉该 scope 产生的所有协程。<br>例如：<br>val job = launch {<br>while (isActive) {<br>log(“launch”)<br>}<br>}<br>delay(1000)<br>job.cancel()</p>
<h1 id="18-内置拓展函数（let-with-run-apply-also）"><a href="#18-内置拓展函数（let-with-run-apply-also）" class="headerlink" title="18. 内置拓展函数（let, with, run, apply, also）"></a>18. 内置拓展函数（let, with, run, apply, also）</h1><p>和 Java 相比，Kotlin 中额外提供了不少高级语法特性，这些高级特性中，定义于 Kotlin 的<br>Standard.kt，提供了一些内置拓展函数以便写出更优雅的代码。<br>18.1. let<br>定义：fun &lt;T, R&gt; T.let( block: (T) -&gt; R ): R<br>功能：调用对象（T）的 let 函数，则该对象为函数的参数。在函数内可以通过 it 指代该对<br>象。返回值为函数的最后一行或指定 return 表达式。<br>any.let {<br> // 用 it 指代 any 对象<br> // todo() 是 any 对象的共有属性或方法<br> // it.todo() 的返回值作为 let 函数的返回值返回<br> it.todo()<br>}<br>let 在使用中可用于空安全验证，变量?.let{}<br>// 另一种用法any?.let {<br> it.todo() // any 不为 null 时才会调用 let 函数<br>}<br>18.2. with<br>和 let 类似，又和 let 不同，with 最后也包含一段函数块，也是将最后的计算的结果返回。<br>但是 with 不是以拓展的形式存在的。其将某个对象作为函数的参数，并且以 this 指代。<br>一般结构：<br>whith(any) {<br>// todo() 是 any 对象的共有属性或方法<br>// todo() 的返回值作为 with 函数的返回值返回<br>todo()<br>}<br>例如，用 with 设置 TextView，由于代码块中传入的是 TextView（this），而不是 it，那么就<br>可以直接写出函数名/属性来进行相应的设置：<br>if (textView == null) return //若 TextView 组件为 null 则进行如下设置<br>with(textView) {<br>text = “TextSetInTextView” //textView.text 属性<br>setTextColor(ContextCompat.getColor(this@TestActivity, R.color.colorAccent))<br>textSize = 18f<br>}<br>这段代码唯一的缺点就是要事先判空了，有没有既能像 let 那样能优雅的判空，又能写出<br>这样的便利的代码呢？那就是下面的 run<br>18.3. run<br>run 函数基本是 let 和 with 的结合体，对象调用 run 函数，接收一个 lambda 函数为参<br>数，传入 this 并以闭包形式返回，返回值是最后的计算结果。<br>一般结构：<br>any.run {<br>// todo() 是 any 对象的共有属性或方法<br>// todo() 的返回值作为 run 函数的返回值返回<br>todo()<br>}<br>TextView 设置各种属性的优化写法如下：<br>textView?.run {<br> text = “TextSetInTextView”<br> setTextColor(ContextCompat.getColor(this@TestActivity, R.color.colorAccent)) textSize = 18f<br>}<br>18.4. apply<br>apply 函数和 run 函数很像，但是 apply 最后返回的是调用对象自身。<br>一般结构：<br>val result = any.apply {<br>todo() // todo() 是 any 对象的共有属性或方法<br>3 * 4 // 最后返回的是 any 对象，而不是 12<br>}<br>println(result) // 打印的是 any 对象<br>18.5. also<br>also 和 let 函数类似，唯一的区别就是 also 函数的返回值是调用对象本身<br>val result = any.also {<br> // 用 it 指代 any 对象<br> // todo() 是 any 对象的共有属性或方法<br> it.todo()<br> 3 * 4 // 将返回 any 对象，而不是 12<br>}<br>具体的调用情况见下图：</p>
<h1 id="19-关键字"><a href="#19-关键字" class="headerlink" title="19. 关键字"></a>19. 关键字</h1><p>19.1. ？的含义<br>在 kotlin 中单独使用？表示可为空；var result = str?.length<br>19.2. ?:的含义<br>表示三元操作符（即三目运算符）<br>var str : String? = null<br>var result = str?.length ?: -1<br>//等价于<br>var result : Int = if(str != null) str.length else -1<br>19.3. :（冒号）<br>类型和超类型之间的冒号前要有一个空格(&gt;:产生歧义)，而实例和类型之间的冒号前不要有空<br>格：<br>interface Foo<out T : Any> : Bar {<br> fun foo(a: Int): T<br>}<br>19.4. ::(双冒号)<br>表示把一个方法当做一个参数，传递到另一个方法中进行使用，就是引用一个方法。<br>19.5. ::class<br>反射中获得 class 的实例，val clazz = Hello::class.jav，Hello::class 获取的是 Kotlin 的<br>KClass<br>19.6. !!（双叹号）<br>非空断言，表示一定不能为空，<br>19.7. abstract :<br>抽象类 一个类或一些成员可能被声明成 abstract 。一个抽象方法在它的类中没有实现方法。<br>注意：抽象类或函数默认是 open 的，不用再添加。<br>19.8. any:<br>相当于 Java 中的 Object<br>19.9. by<br>类委托、属性委托19.10. companion object 伴生对象:<br>类内定义的伴生对象，相当于 java 中的 static 成员<br>companion object {<br>lateinit var instance: App<br>}<br>19.11. const:<br>编译期常量<br>19.12. constructor<br>用于标识构造函数<br>19.13. data class:<br>只包含数据字段的类，编译器自动成了如下方法：<br>equals()/hashCode()、toString()方法、componentN()方法、copy()方法<br>19.14. indices：<br>数组或 list 的索引属性：<br>val array=arrayOf(“a”,”b”,”c”)<br>for( i in array.indices ) println( i ) //分行输出 0,1,2<br>19.15. inline：<br>内联函数<br>19.16. inner:<br>内部类<br>19.17. internal:<br>internal 声明，在同一模块中的任何地方可见<br>19.18. is:<br>自动类型转换<br>19.19. lateinit var 延迟初始化属性：<br>lateinit 修饰的变量/属性不能是原始数据类型。<br>19.20. by lazy 懒属性(延迟加载)<br>val p: String by lazy {// 生成 string 的值<br>}<br>lateinit 只用于 var，lazy 只用于 val<br>lateinit var 只是让编译期忽略对属性未初始化的检查，后续在哪里以及何时初始化还需要开<br>发者自己决定。<br>by lazy 真正做到了声明的同时也指定了延迟初始化时的行为，在属性被第一次被使用的时候<br>能自动初始化。<br>19.21. object（用于创建单例模式）:<br>object Resource {<br>val name = “Name”<br>}<br>19.22. open 说明可以被继承 :<br>19.23. override<br>19.24. reified：<br>作为 Kotlin 的一个方法泛型关键字，代表可以在方法体内访问泛型指定的 JVM 类对象<br>19.25. sealed 密封类：<br>声明密封类需要在 class 前加一个 sealed 修饰符。<br>19.26. tailrec（尾递归）：<br>作用：修身尾递归函数。与普通递归相比，编译器会对尾递归进行修改，将其优化成一个快<br>速而高效的基于循环的版本，这样减少内存消耗。<br>19.27. Unit 类型：<br>如果函数返回 Unit 类型，该返回类型应该省略：<br>19.28. var 和 val：<br>定义可读写和只读变量<br>19.29. typealias：<br>定义类型别名<br>19.30. vararg ：<br>可变参数。一个函数最多只能有一个可变参数。19.31. when 用于判断 相当于 java 中的 switch()语句<br>19.32. 属性修饰符<br>annotation //注解类<br>abstract //抽象类<br>final //类不可继承，默认属性<br>enum //枚举类<br>open //类可继承，类默认是 final </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

        

      
    </div>

      <!-- 相关文章推荐 -->
     
          


     

    
    
    

    <div>
          
            

          
    </div>

    

    <div>
      
        <div>
    
        <div class="read-over">-------------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------------</div>
    
</div>

      
    </div>

    
      <div>
        <div class="share_reward">
  <div>坚持原创技术分享，感谢您的支持和鼓励！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/keke_wechatpay.jpg" alt="YkekeY WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/keke_alipay.jpg" alt="YkekeY Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/27/daily/" rel="next" title="Developer log 开发日志">
                Developer log 开发日志 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
         <div
  data-weibo-title="分享到微博"
  data-qq-title="分享到QQ"
  data-douban-title="分享到豆瓣"
  class="social-share"
  class="share-component"



  data-disabled="qzone,google+,linkedin"
  data-description="Share.js - 一键分享到微博，QQ空间，腾讯微博，人人，豆瓣...">
   分享到：
</div>


      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  






<div id="gitment_title" class="gitment_title"></div>
<div id="container" style="display:none"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script>
  const myTheme = {
    render(state, instance) {
      const container = document.createElement('div');
      container.lang = "en-US";
      container.className = 'gitment-container gitment-root-container';
      container.appendChild(instance.renderHeader(state, instance));
      container.appendChild(instance.renderEditor(state, instance));
      container.appendChild(instance.renderComments(state, instance));
      container.appendChild(instance.renderFooter(state, instance));
      return container;
    }
  }
 
  function showGitment() {
    $("#gitment_title").attr("style", "display:none");
    $("#container").attr("style", "").addClass("gitment_container");
    var gitment = new Gitment({
      id: decodeURI(window.location.pathname),
      theme: myTheme,
      owner: 'YkekeY',
      repo: 'YkekeY.github.io',
      oauth: {
        client_id: 'b99822dcb4c279cc9249',
        client_secret: 'c6f30cb8845a7256d09da3ce900a4cc0bcb4f288'
      }
    });
    gitment.render('container');
  }
 
  showGitment();
</script>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image"
                src="/images/keke.jpg"
                alt="YkekeY" />
              </a>
            
              <p class="site-author-name" itemprop="name">YkekeY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="https://github.com/YkekeY" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a rel="external nofollow" href="mailto:leaf793458585@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

            <!--
            <div id="music163player">
                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1336790004&auto=1&height=66"></iframe>
            </div>
            -->

          
          

          
          

          <!--近期文章版块 began-->
          
              <div class="links-of-blogroll motion-element links-of-blogroll-block">
                <div class="links-of-blogroll-title">
                  <i class="fa fa-history fa-" aria-hidden="true"></i>
                  近期文章
                </div>
                <ul class="links-of-blogroll-list">
                  
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/2021/03/22/kotlinStudy/" title="Kotlin Learn Note" target="_blank">Kotlin Learn Note</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/2020/04/27/daily/" title="Developer log 开发日志" target="_blank">Developer log 开发日志</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/2020/04/25/Problem/" title="Problems to be solved 疑难杂谈(Updating Still)" target="_blank">Problems to be solved 疑难杂谈(Updating Still)</a>
                    </li>
                  
                    <li class='my-links-of-blogroll-li'>
                      <a href="/2020/04/25/welcom/" title="欢迎至科科站点" target="_blank">欢迎至科科站点</a>
                    </li>
                  
                </ul>
              </div>
          
          <!--近期文章版块 end-->

          
              <!-- canvas粒子时钟 -->
              <!-- canvas粒子时钟 https://www.cnblogs.com/xiaohuochai/p/6368039.html
  https://www.html5tricks.com/html5-canvas-dance-time.html
 -->
<div id="">
  <canvas id="canvas" style="width:60%;">
</div>
<script async>
(function(){
  var WINDOW_WIDTH = 820;
  		var WINDOW_HEIGHT = 250;
  		var RADIUS = 7; //球半径
  		var NUMBER_GAP = 10; //数字之间的间隙
  		var u=0.65; //碰撞能量损耗系数
  		var context; //Canvas绘制上下文
  		var balls = []; //存储彩色的小球
  		const colors = ["#33B5E5","#0099CC","#AA66CC","#9933CC","#99CC00","#669900","#FFBB33","#FF8800","#FF4444","#CC0000"]; //彩色小球的颜色
  		var currentNums = []; //屏幕显示的8个字符
  		var digit =
                  [
                      [
                          [0,0,1,1,1,0,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,0,1,1,0],
                          [0,0,1,1,1,0,0]
                      ],//0
                      [
                          [0,0,0,1,1,0,0],
                          [0,1,1,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [1,1,1,1,1,1,1]
                      ],//1
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,1,1],
                          [1,1,1,1,1,1,1]
                      ],//2
                      [
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,1,0,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//3
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,0],
                          [0,0,1,1,1,1,0],
                          [0,1,1,0,1,1,0],
                          [1,1,0,0,1,1,0],
                          [1,1,1,1,1,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,1,1]
                      ],//4
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,1,1,1,1,0],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//5
                      [
                          [0,0,0,0,1,1,0],
                          [0,0,1,1,0,0,0],
                          [0,1,1,0,0,0,0],
                          [1,1,0,0,0,0,0],
                          [1,1,0,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//6
                      [
                          [1,1,1,1,1,1,1],
                          [1,1,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,0,0,1,1,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0],
                          [0,0,1,1,0,0,0]
                      ],//7
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,1,1,0]
                      ],//8
                      [
                          [0,1,1,1,1,1,0],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [1,1,0,0,0,1,1],
                          [0,1,1,1,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,0,1,1],
                          [0,0,0,0,1,1,0],
                          [0,0,0,1,1,0,0],
                          [0,1,1,0,0,0,0]
                      ],//9
                      [
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0],
                          [0,1,1,0],
                          [0,1,1,0],
                          [0,0,0,0],
                          [0,0,0,0]
                      ]//:
                  ];

  		function drawDatetime(cxt){
  			var nums = [];

  			context.fillStyle="#005eac"
  			var date = new Date();
  			var offsetX = 70, offsetY = 30;
  			var hours = date.getHours();
  			var num1 = Math.floor(hours/10);
  			var num2 = hours%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var minutes = date.getMinutes();
  			var num1 = Math.floor(minutes/10);
  			var num2 = minutes%10;
  			nums.push({num: num1});
  			nums.push({num: num2});
  			nums.push({num: 10}); //冒号
  			var seconds = date.getSeconds();
  			var num1 = Math.floor(seconds/10);
  			var num2 = seconds%10;
  			nums.push({num: num1});
  			nums.push({num: num2});

  			for(var x = 0;x<nums.length;x++){
  				nums[x].offsetX = offsetX;
  				offsetX = drawSingleNumber(offsetX,offsetY, nums[x].num,cxt);
  				//两个数字连一块，应该间隔一些距离
  				if(x<nums.length-1){
  					if((nums[x].num!=10) &&(nums[x+1].num!=10)){
  						offsetX+=NUMBER_GAP;
  					}
  				}
  			}

  			//说明这是初始化
  			if(currentNums.length ==0){
  				currentNums = nums;
  			}else{
  				//进行比较
  				for(var index = 0;index<currentNums.length;index++){
  					if(currentNums[index].num!=nums[index].num){
  						//不一样时，添加彩色小球
  						addBalls(nums[index]);
  						currentNums[index].num=nums[index].num;
  					}
  				}
  			}
  			renderBalls(cxt);
  			updateBalls();

  			return date;
  		}

  		function addBalls (item) {
  			var num = item.num;
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						var ball={
  							offsetX:item.offsetX+RADIUS+RADIUS*2*x,
  							offsetY:30+RADIUS+RADIUS*2*y,
  							color:colors[Math.floor(Math.random()*colors.length)],
  							g:1.5+Math.random(),
  							vx:Math.pow(-1, Math.ceil(Math.random()*10))*4+Math.random(),
  							vy:-5
  						}
  						balls.push(ball);
  					}
  				}
  			}
  		}

  		function renderBalls(cxt){
  			for(var index = 0;index<balls.length;index++){
  				cxt.beginPath();
  				cxt.fillStyle=balls[index].color;
  				cxt.arc(balls[index].offsetX, balls[index].offsetY, RADIUS, 0, 2*Math.PI);
  				cxt.fill();
  			}
  		}

  		function updateBalls () {
  			var i =0;
  			for(var index = 0;index<balls.length;index++){
  				var ball = balls[index];
  				ball.offsetX += ball.vx;
  				ball.offsetY += ball.vy;
  				ball.vy+=ball.g;
  				if(ball.offsetY > (WINDOW_HEIGHT-RADIUS)){
  					ball.offsetY= WINDOW_HEIGHT-RADIUS;
  					ball.vy=-ball.vy*u;
  				}
  				if(ball.offsetX>RADIUS&&ball.offsetX<(WINDOW_WIDTH-RADIUS)){

  					balls[i]=balls[index];
  					i++;
  				}
  			}
  			//去除出边界的球
  			for(;i<balls.length;i++){
  				balls.pop();
  			}
  		}
  		function drawSingleNumber(offsetX, offsetY, num, cxt){
  			var numMatrix = digit[num];
  			for(var y = 0;y<numMatrix.length;y++){
  				for(var x = 0;x<numMatrix[y].length;x++){
  					if(numMatrix[y][x]==1){
  						cxt.beginPath();
  						cxt.arc(offsetX+RADIUS+RADIUS*2*x,offsetY+RADIUS+RADIUS*2*y,RADIUS,0,2*Math.PI);
  						cxt.fill();
  					}
  				}
  			}
  			cxt.beginPath();
  			offsetX += numMatrix[0].length*RADIUS*2;
  			return offsetX;
  		}

  		var canvas = document.getElementById("canvas");
  		canvas.width=WINDOW_WIDTH;
  		canvas.height=WINDOW_HEIGHT;
  		context = canvas.getContext("2d");

  		//记录当前绘制的时刻
  		var currentDate = new Date();

  		setInterval(function(){
  			//清空整个Canvas，重新绘制内容
  			context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  			drawDatetime(context);
  		}, 50)
})();
</script>

          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#写在前言"><span class="nav-number">1.</span> <span class="nav-text">写在前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-kotlin-概述"><span class="nav-number">2.</span> <span class="nav-text">1. kotlin 概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-基本语法概述"><span class="nav-number">3.</span> <span class="nav-text">2. 基本语法概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-空值处理"><span class="nav-number">4.</span> <span class="nav-text">3. 空值处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-基本类型"><span class="nav-number">5.</span> <span class="nav-text">4. 基本类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-运算符"><span class="nav-number">6.</span> <span class="nav-text">5. 运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-控制流"><span class="nav-number">7.</span> <span class="nav-text">6. 控制流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-函数"><span class="nav-number">8.</span> <span class="nav-text">7. 函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-可见性修饰符"><span class="nav-number">9.</span> <span class="nav-text">8. 可见性修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-类"><span class="nav-number">10.</span> <span class="nav-text">9. 类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-反射"><span class="nav-number">11.</span> <span class="nav-text">10. 反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-委托对象-被委托对象"><span class="nav-number">12.</span> <span class="nav-text">11. 委托对象 被委托对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-异常"><span class="nav-number">13.</span> <span class="nav-text">12. 异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-泛型"><span class="nav-number">14.</span> <span class="nav-text">13. 泛型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-集合"><span class="nav-number">15.</span> <span class="nav-text">14. 集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-IO"><span class="nav-number">16.</span> <span class="nav-text">15. IO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-线程"><span class="nav-number">17.</span> <span class="nav-text">16. 线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-协程（Coroutine）"><span class="nav-number">18.</span> <span class="nav-text">17. 协程（Coroutine）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-内置拓展函数（let-with-run-apply-also）"><span class="nav-number">19.</span> <span class="nav-text">18. 内置拓展函数（let, with, run, apply, also）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-关键字"><span class="nav-number">20.</span> <span class="nav-text">19. 关键字</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

      

      <!-- 标签云 -->
      <!--
      
      -->
      <!-- 标签云 -->

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
       <i class="fa fa-heartbeat"></i>
  </span>
  <!--
    <span class="author" itemprop="copyrightHolder"> &nbsp;YkekeY</span>
  -->
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="Site words total count"></span>
  
</div>












  <div class="subscribe-box">
    <div class="subscribe-menu">
      <div class="subscribe-hover">
        <div class="subscribe-description">微信扫一扫，关注公众号</div>
      </div>
    </div>
  </div>


        
<div class="busuanzi-count">
  <!--
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  -->
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

   

  
  
    
      <span class="site-uv">
        
        我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友，
      </span>
    

    
      <span class="site-pv">
        历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇
        <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      </span>
    
  

</div>








        
      </div>
    </footer>

    
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="60" alpha="0.1"  zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>

  <!-- https://deserts.io/diy-a-comment-system/ -->
  <script type="text/javascript">
    new Valine({
        lang: 'zh-cn',
        admin_email: 'xxxxxxxxx@qq.com', //博主邮箱
        el: '#comments' ,
        appId: 'JeRiHTCfmwq9YdhIsWaqYuwk-gzGzoHsz',
        appKey: '75DdcETnrWKlspF3mGbgaipo',
        emoticon_url: 'https://cdn.jsdelivr.net/gh/leafjame/cdn/emoji',
       // emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
        emoticon_list: ["大佬.gif","点赞.gif","尴尬.gif","鼓掌.gif","笑哭.gif","害羞.gif","黑人问号.gif","坏笑.gif","惊吓.gif","可爱.gif","抠鼻子.gif","流汗.gif","色.gif","吐血.gif","无奈.gif","huaji.png","liuhanhuaji.png","mojinghuaji.png","coshuaji.png","shounuehuaji.png","jizhi.png","doge.png","chigua.png","motion_1016.png","motion_1012.png","motion_1017.png","f_hufen.png","f_geili.png","f_jiong.png","f_meng.png","f_shenma.png","f_v5.png","c_onef.png","c_onem.png","c_fivem.png","c_oney.png","c_teny.png","c_oy.png","1f60a.png","1f60b.png","1f60d.png","1f60e.png","1f61a.png","1f62d.png","1f601.png","1f602.png","1f605.png","1f606.png","1f607.png","1f618.png","1f630.png","1f631.png","1f632.png","1f633.png","1f63e.png","1f63f.png","1f638.png","1f639.png","zhayanjian.gif","ciya.gif","xieyanxiao.gif","huaixiao.gif","xiaoku.gif","leiben.gif","penxue.gif","hanxiao.gif","baiyan.gif","cahan.gif","fadai.gif","haixiu.gif","haqian.gif","ku.gif","liuhan.gif","OK.gif","qiang.gif","woshou.gif","baoquan.gif","qiudale.gif","se.gif","yinxian.gif","yun.gif","zaijian.gif"],
        placeholder: '&#x270d;&nbsp;写评论',
  });

  <!--点击邮件中的链接跳转至相应评论-->
  if(window.location.hash){
      var checkExist = setInterval(function() {
         if ($(window.location.hash).length) {
            $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
            clearInterval(checkExist);
         }
      }, 100);
   }

  </script>






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  


  <!-- Tidio 在线联系功能、鼠标点击特效、页面反馈...-->
  


  
    <script async src="/js/cursor/fireworks.js"></script>
  










  <script src="/js/src/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>






  <script async language="javascript">

    var div = document.createElement("div");
    //插入到自定义的theme-info或者copyright之后
    var copyright = document.querySelector(".theme-info2") || document.querySelector(".copyright");

    function show_run_time(){
        window.setTimeout("show_run_time()", 1000);
      // BirthDay=new Date("08/07/2019 20:00:00");
        BirthDay=new Date("04/25/2020 20:00:00");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));

        // 使用zh-Hans.yml的文字替换
        div.innerHTML = "我已在此等候你 " + "<span style='color: #1890ff'> " + daysold + " </span> 天 <span style='color: #1890ff'>" + hrsold + " </span>时 <span style='color: #1890ff'>" + minsold + " </span>分 <span style='color: #1890ff'>" + seconds + " </span>秒 ";

        document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);

    }
    function setzero(i){
        if (i<10)
        {i="0" + i};
        return i;
    }

    show_run_time();

  </script>




<!-- 旋转魔方 -->

   
      
<style>
    .cube_container {
      width: 50px;
      height: 60px;
      margin: 0 auto;
      position: fixed;
      z-index: 999;
      -webkit-perspective: 1000px;
              perspective: 1000px;
      right: 0px;
      bottom: 0px;
      -webkit-transform: translate(-50%, -50%);
              transform: translate(-50%, -50%);
    }

    .cube {
      /*
      width: 100%;
      height: 100%;
      */
      width: 0%; /* 大角度旋转 */
      position: absolute;
      -webkit-transform-style: preserve-3d;
      transform-style: preserve-3d;
      -webkit-transform: rotateX(-15deg) rotateY(-20deg) translateZ(-100px);
      transform: rotateX(-15deg) rotateY(-20deg) translateZ(-100px);
      -webkit-transform-origin: center center -100px;
      transform-origin: center center -100px;
      -webkit-animation: around 5s cubic-bezier(0.94, -0.6, 0.45, 1.31) infinite;
      animation: around 5s cubic-bezier(0.94, -0.6, 0.45, 1.31) infinite;
    }
    .cube div {
      width: 50px;
      height: 50px;
      display: block;
      margin: 0;
      position: absolute;
    }
    .cube div a {
      color: white;
      font-size: 12px;
      text-decoration: none;
      text-align: center;
      position: fixed;
      top: 50%;
      left: 45%;
      -webkit-transform: translate(-50%, -50%);
              transform: translate(-50%, -50%);
    }
    .cube .front {
      -webkit-transform: rotateY(0deg) translateZ(25px);
              transform: rotateY(0deg) translateZ(25px);
      background-color: rgba(0, 191, 255, 0.7);
      border: 1px solid rgba(0, 191, 255, 0.7);
    }
    .cube .back {
      -webkit-transform: rotateX(180deg) translateZ(25px);
              transform: rotateX(180deg) translateZ(25px);
      background-color: rgba(124, 252, 0, 0.7);
      border: 1px solid rgba(124, 252, 0, 0.7);
    }
    .cube .left {
      -webkit-transform: rotateY(-90deg) translateZ(25px);
              transform: rotateY(-90deg) translateZ(25px);
      background-color: rgba(255, 215, 0, 0.7);
      border: 1px solid rgba(255, 215, 0, 0.7);
    }
    .cube .right {
      -webkit-transform: rotateY(90deg) translateZ(25px);
              transform: rotateY(90deg) translateZ(25px);
      background-color: rgba(255, 69, 0, 0.7);
      border: 1px solid rgba(255, 69, 0, 0.7);
    }
    .cube .top {
      -webkit-transform: rotateX(90deg) translateZ(25px);
              transform: rotateX(90deg) translateZ(25px);
      background-color: rgba(255, 0, 157, 0.7);
      border: 1px solid rgba(255, 0, 157, 0.7);
    }
    .cube .bottom {
      -webkit-transform: rotateX(-90deg) translateZ(25px);
              transform: rotateX(-90deg) translateZ(25px);
      background-color: rgba(184, 111, 220, 0.7);
      border: 1px solid rgba(184, 111, 220, 0.7);
    }

     @-webkit-keyframes around {
      100% {
        -webkit-transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
                transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
      }
    }

    @keyframes around {
      100% {
        -webkit-transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
        transform: rotateX(-15deg) rotateY(-380deg) translateZ(-100px);
      }
    }
</style>

<div class="cube_container">
	  <div class="cube">
	    <div class="front"><a onclick="back2top()" rel="nofollow"> 欢迎光临 </a></div>
	    <div class="back"><a onclick="back2top()" rel="nofollow"> ❤️ </a></div>
	    <div class="right"><a onclick="back2top()" rel="nofollow"> 科科小站 </a></div>
	    <div class="left"><a onclick="back2top()" role="button" rel="nofollow"> 请多关照 </a></div>
	    <div class="top"><a href="https://github.com/leafjame/hexo-theme-next5-leaf" target="_blank" rel="nofollow"> ❤️ </a></div>
	    <div class="bottom"><a href="https://github.com/leafjame/hexo-theme-next5-leaf" target="_blank" rel="nofollow"> ❤️ </a></div>
	  </div>
</div>

<script>

  function back2top(){
    $('html, body').animate({scrollTop: 0}, 500);
  }

</script>

   


<!-- Console 输出第三方个性化字体 -->

  <script async type="text/javascript" src="/figlet/fetch.min.js"></script>
  <script type="text/javascript" src="/figlet/figlet.js"></script>
  <script type="text/javascript">

      figlet.defaults({fontPath: "/figlet/fonts"});
      figlet("Welcome To YkekeY", "Big Money-ne", function(err, text) {
          if (err) {
              console.log("something went wrong...");
              console.dir(err);
              return;
          }
          console.log(text);
      });
  </script>


  <!-- Console 输出自定义字体 -->
  
    <script async type="text/javascript">
        var text = "Welcome To YkekeY";
        var date = '2021-04-20';
        console.log("%c " + text, "font-size:100px;color:white;border-radius:20px;height:200px; background:-webkit-linear-gradient(yellow,orange,red,green,blue,purple);text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);");
        console.info('\n' + ' %c Leafae Site %c https://ykekey.github.io/ ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
        console.info('\n' + ' %c Leafae QQ %c 793458585 ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
        console.info('\n' + ' %c Leafae Wechat %c leaface ' + '\n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;');
       // console.log("%c Time: " + date, "font-size:100px;white:"+fcolor+";border-radius:20px;height:200px; background:-webkit-linear-gradient(yellow,orange,red,green,blue,purple);text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);  background-image: linear-gradient(to right, orangered, orange, gold, lightgreen, cyan, dodgerblue, mediumpurple, hotpink, orangered);");
       // console.log("%c .", "padding:300px 600px;line-height:10px;background:url(https://s2.ax1x.com/2019/10/17/KkoAJJ.md.png) no-repeat;");
    </script>
  


  <!-- 看板娘 -->
  
      <script async src="/live2d-widget/autoload.js"></script>
  

  

  

  <!-- 代码块复制功能 -->
  <script async type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script async type="text/javascript" src="/js/src/clipboard-use.js"></script>

  <!--share.js-->
  <link async rel="stylesheet" href="/sharejs/css/share.min.css">
  <script async src="/sharejs/js/social-share.min.js"></script>

  <!-- 模仿知乎卡片样式链接、崩溃欺骗特效 -->
  <script async type="text/javascript" src="/js/src/linkcard.js"></script>

  <!--崩溃欺骗 放在js文件最后-->
  <!--
  <script type="text/javascript" src="/js/src/crash_cheat.js"></script>
  -->

 

</body>
</html>
